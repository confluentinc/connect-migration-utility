{
  "template_id": "HdfsSinkConnector",
  "connector_type": "SINK",
  "connector.class": "io.confluent.connect.hdfs.HdfsSinkConnector",
  "name": "{{.logicalClusterId}}",
  "imports": [],
  "group_order": [
    "HDFS",
    "Security",
    "Connector",
    "Storage",
    "Partitioner",
    "Hive",
    "Schema"
  ],
  "config_defs": [
    {
      "name": "hdfs.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 1,
      "display_name": "hdfs.url",
      "documentation": "The HDFS connection URL. This configuration has the format of hdfs://hostname:port and specifies the HDFS to export data to. This property is deprecated and will be removed in future releases. Usestore.urlinstead.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 1
      },
      "default": "nullimportance: high"
    },
    {
      "name": "hadoop.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 2,
      "display_name": "hadoop.conf.dir",
      "documentation": "The Hadoop configuration directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 2
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hadoop.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 3,
      "display_name": "hadoop.home",
      "documentation": "The Hadoop home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 3
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "logs.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 4,
      "display_name": "logs.dir",
      "documentation": "Top level directory to store the write ahead logs. Supports${topic}in the value, which will\nbe replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction withtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: logsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 4
      },
      "default": "logsimportance: high"
    },
    {
      "name": "hdfs.authentication.kerberos",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 5,
      "display_name": "hdfs.authentication.kerberos",
      "documentation": "Configuration indicating whether HDFS is using Kerberos for authentication.Type: booleanDefault: falseImportance: highDependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 5
      },
      "default": "falseimportance: highdependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "dependents": [
        "connect.hdfs.principal",
        "connect.hdfs.keytab",
        "hdfs.namenode.principal",
        "kerberos.ticket.renew.period.ms"
      ]
    },
    {
      "name": "connect.hdfs.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 6,
      "display_name": "connect.hdfs.principal",
      "documentation": "The principal name to load from the keytab for Kerberos authentication.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 6
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "connect.hdfs.keytab",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 7,
      "display_name": "connect.hdfs.keytab",
      "documentation": "The path to the keytab file for the HDFS connector principal. This keytab file should only be readable by the connector user.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 7
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hdfs.namenode.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 8,
      "display_name": "hdfs.namenode.principal",
      "documentation": "The Kerberos principal name for the HDFS Namenode. The format isnn/_HOST@REALM.TLD.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 8
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "kerberos.ticket.renew.period.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 9,
      "display_name": "kerberos.ticket.renew.period.ms",
      "documentation": "The period in milliseconds to renew the Kerberos ticket.Type: longDefault: 3600000 (1 hour)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 9
      },
      "default": "3600000 (1 hour)importance: low"
    },
    {
      "name": "format.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 10,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store. Format classes\nimplement theio.confluent.connect.storage.format.Formatinterface.Type: classDefault:io.confluent.connect.hdfs.avro.AvroFormatImportance: highThese classes are available by default:io.confluent.connect.hdfs.avro.AvroFormatio.confluent.connect.hdfs.json.JsonFormatio.confluent.connect.hdfs.orc.OrcFormatio.confluent.connect.hdfs.parquet.ParquetFormatio.confluent.connect.hdfs.string.StringFormat",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 10
      },
      "default": "io.confluent.connect.hdfs.avro.avroformatimportance: highthese classes are available by default:io.confluent.connect.hdfs.avro.avroformatio.confluent.connect.hdfs.json.jsonformatio.confluent.connect.hdfs.orc.orcformatio.confluent.connect.hdfs.parquet.parquetformatio.confluent.connect.hdfs.string.stringformat"
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 11,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: highImportantRotation strategy logic:In the following rotation strategies, the logic to flush files to storage is triggered when a new record arrives,afterthe defined interval or scheduled interval time. Flushing files is also triggered periodically by theoffset.flush.interval.mssetting defined in the Connect worker configuration. Theoffset.flush.interval.mssetting defaults to 60000 ms (60 seconds). If you enable the propertiesrotate.interval.msorrotate.schedule.interval.msand ingestion rate is low, you should setoffset.flush.interval.msto a smaller value so that records flush at the rotation interval (or close to the interval) .  Leaving theoffset.flush.interval.msset to the default 60 seconds may cause records to stay in an open file for longer than expected, if no new records get processed that trigger rotation.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 11
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 12,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. This configuration ensures that file commits are invoked every configured interval. This configuration is useful when data ingestion rate is low and the connector didn\u00e2\u0080\u0099t write enough messages to commit files. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 12
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 13,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This configuration ensures that file commits are invoked every configured interval. Time of commit will be adjusted to 00:00 of selected timezone. Commit will be performed at scheduled time regardless previous commit time or number of messages. This configuration is useful when you have to commit your data based on current server time, like at the beginning of every hour. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 13
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schemas.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 14,
      "display_name": "schemas.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 14
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 15,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: trueImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 15
      },
      "default": "trueimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 16,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 16
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 17,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000 (5 seconds)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 17
      },
      "default": "5000 (5 seconds)importance: low"
    },
    {
      "name": "shutdown.timeout.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 18,
      "display_name": "shutdown.timeout.ms",
      "documentation": "Clean shutdown timeout. This makes sure that asynchronous Hive metastore updates are completed during connector shutdown.Type: longDefault: 3000 (3 seconds)Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 18
      },
      "default": "3000 (3 seconds)importance: medium"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 19,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 19
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 20,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output files. Available values: null, deflate, snappy and bzip2 (Codec source is org.apache.avro.file.CodecFactory).Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 20
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "parquet.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 21,
      "display_name": "parquet.codec",
      "documentation": "The Parquet compression codec to be used for output files.Type: stringDefault: snappyValid Values: [none, snappy, gzip, brotli, lz4, lzo, zstd]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 21
      },
      "default": "snappyvalid values: [none, snappy, gzip, brotli, lz4, lzo, zstd]importance: low",
      "valid_values": [
        "none",
        "snappy",
        "gzip",
        "brotli",
        "lz4",
        "lzo",
        "zstd"
      ]
    },
    {
      "name": "storage.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 22,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classDefault: io.confluent.connect.hdfs.storage.HdfsStorageImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 22
      },
      "default": "io.confluent.connect.hdfs.storage.hdfsstorageimportance: high"
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 23,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Apache Kafka\u00c2\u00ae. Supports${topic}in the value,\nwhich will be replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction\nwithtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 23
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 24,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable. For example:hdfs://hostname:port.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 24
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 25,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 25
      },
      "default": "/importance: medium"
    },
    {
      "name": "topic.capture.groups.regex",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 26,
      "display_name": "topic.capture.groups.regex",
      "documentation": "A Java Pattern regex that matches the entire topic and captures values for substituting intotopics.dir. Indexed capture groups are accessible with${n}, where${0}refers to the whole match and${1}refers to the first capture group. Example config value of([a-zA-Z]*)_([a-zA-Z]*)will match topics that are two words delimited by an underscore and will capture each word separately. Withtopic.dir=${1}/${2}, a record from the topicexample_namewill be written into a subdirectory ofexample/name/. By default, this functionality is not enabled.Type: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 26
      },
      "default": "nullimportance: low"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 27,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. The following partitioners are available:DefaultPartitionerpreserves the Kafka partitions.DailyPartitionerpartitions data according to date.HourlyPartitionerpartitions data according to hour.FieldPartitionerpartitions the data to different directories according to the value of the partitioning field\nspecified inpartition.field.name.TimeBasedPartitionerpartitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 27
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 28,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field whenFieldPartitioneris used. You can enter multiple partitioning field names using comma-separated names.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 28
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 29,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 29
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 30,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 30
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 31,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 31
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 32,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Any timezone accepted by: classorg.joda.time.DateTimeZoneImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 32
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: any timezone accepted by: classorg.joda.time.datetimezoneimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 33,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 33
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 34,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 34
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "hive.integration",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 35,
      "display_name": "hive.integration",
      "documentation": "Configuration indicating whether to integrate with Hive when running the connector.Type: booleanDefault: falseImportance: highDependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 35
      },
      "default": "falseimportance: highdependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "dependents": [
        "hive.metastore.uris",
        "hive.conf.dir",
        "hive.home",
        "hive.database"
      ]
    },
    {
      "name": "hive.metastore.uris",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 36,
      "display_name": "hive.metastore.uris",
      "documentation": "The Hive metastore URIs, can be IP address or fully-qualified domain name and port of the metastore host.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 36
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 37,
      "display_name": "hive.conf.dir",
      "documentation": "Hive configuration directoryType: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 37
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 38,
      "display_name": "hive.home",
      "documentation": "Hive home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 38
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.database",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 39,
      "display_name": "hive.database",
      "documentation": "The database to use when the connector creates tables in Hive.Type: stringDefault: defaultImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 39
      },
      "default": "defaultimportance: high"
    },
    {
      "name": "hive.table.name",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 40,
      "display_name": "hive.table.name",
      "documentation": "The hive table name to use.\nIt must contain${topic}to inject the corresponding topic name.Type: stringDefault: \u00e2\u0080\u009c${topic}\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 40
      },
      "default": "\u00e2\u0080\u009c${topic}\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 41,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 41
      },
      "default": "noneimportance: high"
    },
    {
      "name": "hdfs.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 42,
      "display_name": "hdfs.url",
      "documentation": "The HDFS connection URL. This configuration has the format of hdfs://hostname:port and specifies the HDFS to export data to. This property is deprecated and will be removed in future releases. Usestore.urlinstead.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 42
      },
      "default": "nullimportance: high"
    },
    {
      "name": "hadoop.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 43,
      "display_name": "hadoop.conf.dir",
      "documentation": "The Hadoop configuration directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 43
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hadoop.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 44,
      "display_name": "hadoop.home",
      "documentation": "The Hadoop home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 44
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "logs.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 45,
      "display_name": "logs.dir",
      "documentation": "Top level directory to store the write ahead logs. Supports${topic}in the value, which will\nbe replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction withtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: logsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 45
      },
      "default": "logsimportance: high"
    },
    {
      "name": "hdfs.authentication.kerberos",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 46,
      "display_name": "hdfs.authentication.kerberos",
      "documentation": "Configuration indicating whether HDFS is using Kerberos for authentication.Type: booleanDefault: falseImportance: highDependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 46
      },
      "default": "falseimportance: highdependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "dependents": [
        "connect.hdfs.principal",
        "connect.hdfs.keytab",
        "hdfs.namenode.principal",
        "kerberos.ticket.renew.period.ms"
      ]
    },
    {
      "name": "connect.hdfs.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 47,
      "display_name": "connect.hdfs.principal",
      "documentation": "The principal name to load from the keytab for Kerberos authentication.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 47
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "connect.hdfs.keytab",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 48,
      "display_name": "connect.hdfs.keytab",
      "documentation": "The path to the keytab file for the HDFS connector principal. This keytab file should only be readable by the connector user.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 48
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hdfs.namenode.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 49,
      "display_name": "hdfs.namenode.principal",
      "documentation": "The Kerberos principal name for the HDFS Namenode. The format isnn/_HOST@REALM.TLD.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 49
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "kerberos.ticket.renew.period.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 50,
      "display_name": "kerberos.ticket.renew.period.ms",
      "documentation": "The period in milliseconds to renew the Kerberos ticket.Type: longDefault: 3600000 (1 hour)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 50
      },
      "default": "3600000 (1 hour)importance: low"
    },
    {
      "name": "format.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 51,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store. Format classes\nimplement theio.confluent.connect.storage.format.Formatinterface.Type: classDefault:io.confluent.connect.hdfs.avro.AvroFormatImportance: highThese classes are available by default:io.confluent.connect.hdfs.avro.AvroFormatio.confluent.connect.hdfs.json.JsonFormatio.confluent.connect.hdfs.orc.OrcFormatio.confluent.connect.hdfs.parquet.ParquetFormatio.confluent.connect.hdfs.string.StringFormat",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 51
      },
      "default": "io.confluent.connect.hdfs.avro.avroformatimportance: highthese classes are available by default:io.confluent.connect.hdfs.avro.avroformatio.confluent.connect.hdfs.json.jsonformatio.confluent.connect.hdfs.orc.orcformatio.confluent.connect.hdfs.parquet.parquetformatio.confluent.connect.hdfs.string.stringformat"
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 52,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: highImportantRotation strategy logic:In the following rotation strategies, the logic to flush files to storage is triggered when a new record arrives,afterthe defined interval or scheduled interval time. Flushing files is also triggered periodically by theoffset.flush.interval.mssetting defined in the Connect worker configuration. Theoffset.flush.interval.mssetting defaults to 60000 ms (60 seconds). If you enable the propertiesrotate.interval.msorrotate.schedule.interval.msand ingestion rate is low, you should setoffset.flush.interval.msto a smaller value so that records flush at the rotation interval (or close to the interval) .  Leaving theoffset.flush.interval.msset to the default 60 seconds may cause records to stay in an open file for longer than expected, if no new records get processed that trigger rotation.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 52
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 53,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. This configuration ensures that file commits are invoked every configured interval. This configuration is useful when data ingestion rate is low and the connector didn\u00e2\u0080\u0099t write enough messages to commit files. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 53
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 54,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This configuration ensures that file commits are invoked every configured interval. Time of commit will be adjusted to 00:00 of selected timezone. Commit will be performed at scheduled time regardless previous commit time or number of messages. This configuration is useful when you have to commit your data based on current server time, like at the beginning of every hour. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 54
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schemas.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 55,
      "display_name": "schemas.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 55
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 56,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: trueImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 56
      },
      "default": "trueimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 57,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 57
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 58,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000 (5 seconds)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 58
      },
      "default": "5000 (5 seconds)importance: low"
    },
    {
      "name": "shutdown.timeout.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 59,
      "display_name": "shutdown.timeout.ms",
      "documentation": "Clean shutdown timeout. This makes sure that asynchronous Hive metastore updates are completed during connector shutdown.Type: longDefault: 3000 (3 seconds)Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 59
      },
      "default": "3000 (3 seconds)importance: medium"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 60,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 60
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 61,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output files. Available values: null, deflate, snappy and bzip2 (Codec source is org.apache.avro.file.CodecFactory).Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 61
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "parquet.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 62,
      "display_name": "parquet.codec",
      "documentation": "The Parquet compression codec to be used for output files.Type: stringDefault: snappyValid Values: [none, snappy, gzip, brotli, lz4, lzo, zstd]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 62
      },
      "default": "snappyvalid values: [none, snappy, gzip, brotli, lz4, lzo, zstd]importance: low",
      "valid_values": [
        "none",
        "snappy",
        "gzip",
        "brotli",
        "lz4",
        "lzo",
        "zstd"
      ]
    },
    {
      "name": "storage.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 63,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classDefault: io.confluent.connect.hdfs.storage.HdfsStorageImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 63
      },
      "default": "io.confluent.connect.hdfs.storage.hdfsstorageimportance: high"
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 64,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Apache Kafka\u00c2\u00ae. Supports${topic}in the value,\nwhich will be replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction\nwithtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 64
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 65,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable. For example:hdfs://hostname:port.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 65
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 66,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 66
      },
      "default": "/importance: medium"
    },
    {
      "name": "topic.capture.groups.regex",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 67,
      "display_name": "topic.capture.groups.regex",
      "documentation": "A Java Pattern regex that matches the entire topic and captures values for substituting intotopics.dir. Indexed capture groups are accessible with${n}, where${0}refers to the whole match and${1}refers to the first capture group. Example config value of([a-zA-Z]*)_([a-zA-Z]*)will match topics that are two words delimited by an underscore and will capture each word separately. Withtopic.dir=${1}/${2}, a record from the topicexample_namewill be written into a subdirectory ofexample/name/. By default, this functionality is not enabled.Type: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 67
      },
      "default": "nullimportance: low"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 68,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. The following partitioners are available:DefaultPartitionerpreserves the Kafka partitions.DailyPartitionerpartitions data according to date.HourlyPartitionerpartitions data according to hour.FieldPartitionerpartitions the data to different directories according to the value of the partitioning field\nspecified inpartition.field.name.TimeBasedPartitionerpartitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 68
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 69,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field whenFieldPartitioneris used. You can enter multiple partitioning field names using comma-separated names.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 69
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 70,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 70
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 71,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 71
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 72,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 72
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 73,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Any timezone accepted by: classorg.joda.time.DateTimeZoneImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 73
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: any timezone accepted by: classorg.joda.time.datetimezoneimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 74,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 74
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 75,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 75
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "hive.integration",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 76,
      "display_name": "hive.integration",
      "documentation": "Configuration indicating whether to integrate with Hive when running the connector.Type: booleanDefault: falseImportance: highDependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 76
      },
      "default": "falseimportance: highdependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "dependents": [
        "hive.metastore.uris",
        "hive.conf.dir",
        "hive.home",
        "hive.database"
      ]
    },
    {
      "name": "hive.metastore.uris",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 77,
      "display_name": "hive.metastore.uris",
      "documentation": "The Hive metastore URIs, can be IP address or fully-qualified domain name and port of the metastore host.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 77
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 78,
      "display_name": "hive.conf.dir",
      "documentation": "Hive configuration directoryType: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 78
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 79,
      "display_name": "hive.home",
      "documentation": "Hive home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 79
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.database",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 80,
      "display_name": "hive.database",
      "documentation": "The database to use when the connector creates tables in Hive.Type: stringDefault: defaultImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 80
      },
      "default": "defaultimportance: high"
    },
    {
      "name": "hive.table.name",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 81,
      "display_name": "hive.table.name",
      "documentation": "The hive table name to use.\nIt must contain${topic}to inject the corresponding topic name.Type: stringDefault: \u00e2\u0080\u009c${topic}\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 81
      },
      "default": "\u00e2\u0080\u009c${topic}\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 82,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 82
      },
      "default": "noneimportance: high"
    },
    {
      "name": "hdfs.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 83,
      "display_name": "hdfs.url",
      "documentation": "The HDFS connection URL. This configuration has the format of hdfs://hostname:port and specifies the HDFS to export data to. This property is deprecated and will be removed in future releases. Usestore.urlinstead.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 83
      },
      "default": "nullimportance: high"
    },
    {
      "name": "hadoop.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 84,
      "display_name": "hadoop.conf.dir",
      "documentation": "The Hadoop configuration directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 84
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hadoop.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 85,
      "display_name": "hadoop.home",
      "documentation": "The Hadoop home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 85
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "logs.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 86,
      "display_name": "logs.dir",
      "documentation": "Top level directory to store the write ahead logs. Supports${topic}in the value, which will\nbe replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction withtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: logsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 86
      },
      "default": "logsimportance: high"
    },
    {
      "name": "hdfs.authentication.kerberos",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 87,
      "display_name": "hdfs.authentication.kerberos",
      "documentation": "Configuration indicating whether HDFS is using Kerberos for authentication.Type: booleanDefault: falseImportance: highDependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 87
      },
      "default": "falseimportance: highdependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "dependents": [
        "connect.hdfs.principal",
        "connect.hdfs.keytab",
        "hdfs.namenode.principal",
        "kerberos.ticket.renew.period.ms"
      ]
    },
    {
      "name": "connect.hdfs.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 88,
      "display_name": "connect.hdfs.principal",
      "documentation": "The principal name to load from the keytab for Kerberos authentication.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 88
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "connect.hdfs.keytab",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 89,
      "display_name": "connect.hdfs.keytab",
      "documentation": "The path to the keytab file for the HDFS connector principal. This keytab file should only be readable by the connector user.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 89
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hdfs.namenode.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 90,
      "display_name": "hdfs.namenode.principal",
      "documentation": "The Kerberos principal name for the HDFS Namenode. The format isnn/_HOST@REALM.TLD.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 90
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "kerberos.ticket.renew.period.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 91,
      "display_name": "kerberos.ticket.renew.period.ms",
      "documentation": "The period in milliseconds to renew the Kerberos ticket.Type: longDefault: 3600000 (1 hour)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 91
      },
      "default": "3600000 (1 hour)importance: low"
    },
    {
      "name": "format.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 92,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store. Format classes\nimplement theio.confluent.connect.storage.format.Formatinterface.Type: classDefault:io.confluent.connect.hdfs.avro.AvroFormatImportance: highThese classes are available by default:io.confluent.connect.hdfs.avro.AvroFormatio.confluent.connect.hdfs.json.JsonFormatio.confluent.connect.hdfs.orc.OrcFormatio.confluent.connect.hdfs.parquet.ParquetFormatio.confluent.connect.hdfs.string.StringFormat",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 92
      },
      "default": "io.confluent.connect.hdfs.avro.avroformatimportance: highthese classes are available by default:io.confluent.connect.hdfs.avro.avroformatio.confluent.connect.hdfs.json.jsonformatio.confluent.connect.hdfs.orc.orcformatio.confluent.connect.hdfs.parquet.parquetformatio.confluent.connect.hdfs.string.stringformat"
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 93,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: highImportantRotation strategy logic:In the following rotation strategies, the logic to flush files to storage is triggered when a new record arrives,afterthe defined interval or scheduled interval time. Flushing files is also triggered periodically by theoffset.flush.interval.mssetting defined in the Connect worker configuration. Theoffset.flush.interval.mssetting defaults to 60000 ms (60 seconds). If you enable the propertiesrotate.interval.msorrotate.schedule.interval.msand ingestion rate is low, you should setoffset.flush.interval.msto a smaller value so that records flush at the rotation interval (or close to the interval) .  Leaving theoffset.flush.interval.msset to the default 60 seconds may cause records to stay in an open file for longer than expected, if no new records get processed that trigger rotation.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 93
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 94,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. This configuration ensures that file commits are invoked every configured interval. This configuration is useful when data ingestion rate is low and the connector didn\u00e2\u0080\u0099t write enough messages to commit files. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 94
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 95,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This configuration ensures that file commits are invoked every configured interval. Time of commit will be adjusted to 00:00 of selected timezone. Commit will be performed at scheduled time regardless previous commit time or number of messages. This configuration is useful when you have to commit your data based on current server time, like at the beginning of every hour. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 95
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schemas.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 96,
      "display_name": "schemas.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 96
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 97,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: trueImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 97
      },
      "default": "trueimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 98,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 98
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 99,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000 (5 seconds)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 99
      },
      "default": "5000 (5 seconds)importance: low"
    },
    {
      "name": "shutdown.timeout.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 100,
      "display_name": "shutdown.timeout.ms",
      "documentation": "Clean shutdown timeout. This makes sure that asynchronous Hive metastore updates are completed during connector shutdown.Type: longDefault: 3000 (3 seconds)Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 100
      },
      "default": "3000 (3 seconds)importance: medium"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 101,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 101
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 102,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output files. Available values: null, deflate, snappy and bzip2 (Codec source is org.apache.avro.file.CodecFactory).Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 102
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "parquet.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 103,
      "display_name": "parquet.codec",
      "documentation": "The Parquet compression codec to be used for output files.Type: stringDefault: snappyValid Values: [none, snappy, gzip, brotli, lz4, lzo, zstd]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 103
      },
      "default": "snappyvalid values: [none, snappy, gzip, brotli, lz4, lzo, zstd]importance: low",
      "valid_values": [
        "none",
        "snappy",
        "gzip",
        "brotli",
        "lz4",
        "lzo",
        "zstd"
      ]
    },
    {
      "name": "storage.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 104,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classDefault: io.confluent.connect.hdfs.storage.HdfsStorageImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 104
      },
      "default": "io.confluent.connect.hdfs.storage.hdfsstorageimportance: high"
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 105,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Apache Kafka\u00c2\u00ae. Supports${topic}in the value,\nwhich will be replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction\nwithtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 105
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 106,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable. For example:hdfs://hostname:port.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 106
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 107,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 107
      },
      "default": "/importance: medium"
    },
    {
      "name": "topic.capture.groups.regex",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 108,
      "display_name": "topic.capture.groups.regex",
      "documentation": "A Java Pattern regex that matches the entire topic and captures values for substituting intotopics.dir. Indexed capture groups are accessible with${n}, where${0}refers to the whole match and${1}refers to the first capture group. Example config value of([a-zA-Z]*)_([a-zA-Z]*)will match topics that are two words delimited by an underscore and will capture each word separately. Withtopic.dir=${1}/${2}, a record from the topicexample_namewill be written into a subdirectory ofexample/name/. By default, this functionality is not enabled.Type: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 108
      },
      "default": "nullimportance: low"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 109,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. The following partitioners are available:DefaultPartitionerpreserves the Kafka partitions.DailyPartitionerpartitions data according to date.HourlyPartitionerpartitions data according to hour.FieldPartitionerpartitions the data to different directories according to the value of the partitioning field\nspecified inpartition.field.name.TimeBasedPartitionerpartitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 109
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 110,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field whenFieldPartitioneris used. You can enter multiple partitioning field names using comma-separated names.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 110
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 111,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 111
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 112,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 112
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 113,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 113
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 114,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Any timezone accepted by: classorg.joda.time.DateTimeZoneImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 114
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: any timezone accepted by: classorg.joda.time.datetimezoneimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 115,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 115
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 116,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 116
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "hive.integration",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 117,
      "display_name": "hive.integration",
      "documentation": "Configuration indicating whether to integrate with Hive when running the connector.Type: booleanDefault: falseImportance: highDependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 117
      },
      "default": "falseimportance: highdependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "dependents": [
        "hive.metastore.uris",
        "hive.conf.dir",
        "hive.home",
        "hive.database"
      ]
    },
    {
      "name": "hive.metastore.uris",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 118,
      "display_name": "hive.metastore.uris",
      "documentation": "The Hive metastore URIs, can be IP address or fully-qualified domain name and port of the metastore host.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 118
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 119,
      "display_name": "hive.conf.dir",
      "documentation": "Hive configuration directoryType: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 119
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 120,
      "display_name": "hive.home",
      "documentation": "Hive home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 120
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.database",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 121,
      "display_name": "hive.database",
      "documentation": "The database to use when the connector creates tables in Hive.Type: stringDefault: defaultImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 121
      },
      "default": "defaultimportance: high"
    },
    {
      "name": "hive.table.name",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 122,
      "display_name": "hive.table.name",
      "documentation": "The hive table name to use.\nIt must contain${topic}to inject the corresponding topic name.Type: stringDefault: \u00e2\u0080\u009c${topic}\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 122
      },
      "default": "\u00e2\u0080\u009c${topic}\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 123,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 123
      },
      "default": "noneimportance: high"
    },
    {
      "name": "hdfs.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 124,
      "display_name": "hdfs.url",
      "documentation": "The HDFS connection URL. This configuration has the format of hdfs://hostname:port and specifies the HDFS to export data to. This property is deprecated and will be removed in future releases. Usestore.urlinstead.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 124
      },
      "default": "nullimportance: high"
    },
    {
      "name": "hadoop.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 125,
      "display_name": "hadoop.conf.dir",
      "documentation": "The Hadoop configuration directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 125
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hadoop.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 126,
      "display_name": "hadoop.home",
      "documentation": "The Hadoop home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 126
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "logs.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 127,
      "display_name": "logs.dir",
      "documentation": "Top level directory to store the write ahead logs. Supports${topic}in the value, which will\nbe replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction withtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: logsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 127
      },
      "default": "logsimportance: high"
    },
    {
      "name": "hdfs.authentication.kerberos",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 128,
      "display_name": "hdfs.authentication.kerberos",
      "documentation": "Configuration indicating whether HDFS is using Kerberos for authentication.Type: booleanDefault: falseImportance: highDependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 128
      },
      "default": "falseimportance: highdependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "dependents": [
        "connect.hdfs.principal",
        "connect.hdfs.keytab",
        "hdfs.namenode.principal",
        "kerberos.ticket.renew.period.ms"
      ]
    },
    {
      "name": "connect.hdfs.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 129,
      "display_name": "connect.hdfs.principal",
      "documentation": "The principal name to load from the keytab for Kerberos authentication.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 129
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "connect.hdfs.keytab",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 130,
      "display_name": "connect.hdfs.keytab",
      "documentation": "The path to the keytab file for the HDFS connector principal. This keytab file should only be readable by the connector user.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 130
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hdfs.namenode.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 131,
      "display_name": "hdfs.namenode.principal",
      "documentation": "The Kerberos principal name for the HDFS Namenode. The format isnn/_HOST@REALM.TLD.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 131
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "kerberos.ticket.renew.period.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 132,
      "display_name": "kerberos.ticket.renew.period.ms",
      "documentation": "The period in milliseconds to renew the Kerberos ticket.Type: longDefault: 3600000 (1 hour)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 132
      },
      "default": "3600000 (1 hour)importance: low"
    },
    {
      "name": "format.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 133,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store. Format classes\nimplement theio.confluent.connect.storage.format.Formatinterface.Type: classDefault:io.confluent.connect.hdfs.avro.AvroFormatImportance: highThese classes are available by default:io.confluent.connect.hdfs.avro.AvroFormatio.confluent.connect.hdfs.json.JsonFormatio.confluent.connect.hdfs.orc.OrcFormatio.confluent.connect.hdfs.parquet.ParquetFormatio.confluent.connect.hdfs.string.StringFormat",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 133
      },
      "default": "io.confluent.connect.hdfs.avro.avroformatimportance: highthese classes are available by default:io.confluent.connect.hdfs.avro.avroformatio.confluent.connect.hdfs.json.jsonformatio.confluent.connect.hdfs.orc.orcformatio.confluent.connect.hdfs.parquet.parquetformatio.confluent.connect.hdfs.string.stringformat"
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 134,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: highImportantRotation strategy logic:In the following rotation strategies, the logic to flush files to storage is triggered when a new record arrives,afterthe defined interval or scheduled interval time. Flushing files is also triggered periodically by theoffset.flush.interval.mssetting defined in the Connect worker configuration. Theoffset.flush.interval.mssetting defaults to 60000 ms (60 seconds). If you enable the propertiesrotate.interval.msorrotate.schedule.interval.msand ingestion rate is low, you should setoffset.flush.interval.msto a smaller value so that records flush at the rotation interval (or close to the interval) .  Leaving theoffset.flush.interval.msset to the default 60 seconds may cause records to stay in an open file for longer than expected, if no new records get processed that trigger rotation.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 134
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 135,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. This configuration ensures that file commits are invoked every configured interval. This configuration is useful when data ingestion rate is low and the connector didn\u00e2\u0080\u0099t write enough messages to commit files. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 135
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 136,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This configuration ensures that file commits are invoked every configured interval. Time of commit will be adjusted to 00:00 of selected timezone. Commit will be performed at scheduled time regardless previous commit time or number of messages. This configuration is useful when you have to commit your data based on current server time, like at the beginning of every hour. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 136
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schemas.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 137,
      "display_name": "schemas.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 137
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 138,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: trueImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 138
      },
      "default": "trueimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 139,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 139
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 140,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000 (5 seconds)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 140
      },
      "default": "5000 (5 seconds)importance: low"
    },
    {
      "name": "shutdown.timeout.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 141,
      "display_name": "shutdown.timeout.ms",
      "documentation": "Clean shutdown timeout. This makes sure that asynchronous Hive metastore updates are completed during connector shutdown.Type: longDefault: 3000 (3 seconds)Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 141
      },
      "default": "3000 (3 seconds)importance: medium"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 142,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 142
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 143,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output files. Available values: null, deflate, snappy and bzip2 (Codec source is org.apache.avro.file.CodecFactory).Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 143
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "parquet.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 144,
      "display_name": "parquet.codec",
      "documentation": "The Parquet compression codec to be used for output files.Type: stringDefault: snappyValid Values: [none, snappy, gzip, brotli, lz4, lzo, zstd]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 144
      },
      "default": "snappyvalid values: [none, snappy, gzip, brotli, lz4, lzo, zstd]importance: low",
      "valid_values": [
        "none",
        "snappy",
        "gzip",
        "brotli",
        "lz4",
        "lzo",
        "zstd"
      ]
    },
    {
      "name": "storage.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 145,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classDefault: io.confluent.connect.hdfs.storage.HdfsStorageImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 145
      },
      "default": "io.confluent.connect.hdfs.storage.hdfsstorageimportance: high"
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 146,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Apache Kafka\u00c2\u00ae. Supports${topic}in the value,\nwhich will be replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction\nwithtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 146
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 147,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable. For example:hdfs://hostname:port.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 147
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 148,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 148
      },
      "default": "/importance: medium"
    },
    {
      "name": "topic.capture.groups.regex",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 149,
      "display_name": "topic.capture.groups.regex",
      "documentation": "A Java Pattern regex that matches the entire topic and captures values for substituting intotopics.dir. Indexed capture groups are accessible with${n}, where${0}refers to the whole match and${1}refers to the first capture group. Example config value of([a-zA-Z]*)_([a-zA-Z]*)will match topics that are two words delimited by an underscore and will capture each word separately. Withtopic.dir=${1}/${2}, a record from the topicexample_namewill be written into a subdirectory ofexample/name/. By default, this functionality is not enabled.Type: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 149
      },
      "default": "nullimportance: low"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 150,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. The following partitioners are available:DefaultPartitionerpreserves the Kafka partitions.DailyPartitionerpartitions data according to date.HourlyPartitionerpartitions data according to hour.FieldPartitionerpartitions the data to different directories according to the value of the partitioning field\nspecified inpartition.field.name.TimeBasedPartitionerpartitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 150
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 151,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field whenFieldPartitioneris used. You can enter multiple partitioning field names using comma-separated names.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 151
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 152,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 152
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 153,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 153
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 154,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 154
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 155,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Any timezone accepted by: classorg.joda.time.DateTimeZoneImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 155
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: any timezone accepted by: classorg.joda.time.datetimezoneimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 156,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 156
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 157,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 157
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "hive.integration",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 158,
      "display_name": "hive.integration",
      "documentation": "Configuration indicating whether to integrate with Hive when running the connector.Type: booleanDefault: falseImportance: highDependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 158
      },
      "default": "falseimportance: highdependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "dependents": [
        "hive.metastore.uris",
        "hive.conf.dir",
        "hive.home",
        "hive.database"
      ]
    },
    {
      "name": "hive.metastore.uris",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 159,
      "display_name": "hive.metastore.uris",
      "documentation": "The Hive metastore URIs, can be IP address or fully-qualified domain name and port of the metastore host.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 159
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 160,
      "display_name": "hive.conf.dir",
      "documentation": "Hive configuration directoryType: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 160
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 161,
      "display_name": "hive.home",
      "documentation": "Hive home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 161
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.database",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 162,
      "display_name": "hive.database",
      "documentation": "The database to use when the connector creates tables in Hive.Type: stringDefault: defaultImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 162
      },
      "default": "defaultimportance: high"
    },
    {
      "name": "hive.table.name",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 163,
      "display_name": "hive.table.name",
      "documentation": "The hive table name to use.\nIt must contain${topic}to inject the corresponding topic name.Type: stringDefault: \u00e2\u0080\u009c${topic}\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 163
      },
      "default": "\u00e2\u0080\u009c${topic}\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 164,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 164
      },
      "default": "noneimportance: high"
    },
    {
      "name": "hdfs.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 165,
      "display_name": "hdfs.url",
      "documentation": "The HDFS connection URL. This configuration has the format of hdfs://hostname:port and specifies the HDFS to export data to. This property is deprecated and will be removed in future releases. Usestore.urlinstead.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 165
      },
      "default": "nullimportance: high"
    },
    {
      "name": "hadoop.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 166,
      "display_name": "hadoop.conf.dir",
      "documentation": "The Hadoop configuration directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 166
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hadoop.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 167,
      "display_name": "hadoop.home",
      "documentation": "The Hadoop home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 167
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "logs.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 168,
      "display_name": "logs.dir",
      "documentation": "Top level directory to store the write ahead logs. Supports${topic}in the value, which will\nbe replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction withtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: logsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 168
      },
      "default": "logsimportance: high"
    },
    {
      "name": "hdfs.authentication.kerberos",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 169,
      "display_name": "hdfs.authentication.kerberos",
      "documentation": "Configuration indicating whether HDFS is using Kerberos for authentication.Type: booleanDefault: falseImportance: highDependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 169
      },
      "default": "falseimportance: highdependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "dependents": [
        "connect.hdfs.principal",
        "connect.hdfs.keytab",
        "hdfs.namenode.principal",
        "kerberos.ticket.renew.period.ms"
      ]
    },
    {
      "name": "connect.hdfs.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 170,
      "display_name": "connect.hdfs.principal",
      "documentation": "The principal name to load from the keytab for Kerberos authentication.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 170
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "connect.hdfs.keytab",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 171,
      "display_name": "connect.hdfs.keytab",
      "documentation": "The path to the keytab file for the HDFS connector principal. This keytab file should only be readable by the connector user.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 171
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hdfs.namenode.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 172,
      "display_name": "hdfs.namenode.principal",
      "documentation": "The Kerberos principal name for the HDFS Namenode. The format isnn/_HOST@REALM.TLD.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 172
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "kerberos.ticket.renew.period.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 173,
      "display_name": "kerberos.ticket.renew.period.ms",
      "documentation": "The period in milliseconds to renew the Kerberos ticket.Type: longDefault: 3600000 (1 hour)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 173
      },
      "default": "3600000 (1 hour)importance: low"
    },
    {
      "name": "format.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 174,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store. Format classes\nimplement theio.confluent.connect.storage.format.Formatinterface.Type: classDefault:io.confluent.connect.hdfs.avro.AvroFormatImportance: highThese classes are available by default:io.confluent.connect.hdfs.avro.AvroFormatio.confluent.connect.hdfs.json.JsonFormatio.confluent.connect.hdfs.orc.OrcFormatio.confluent.connect.hdfs.parquet.ParquetFormatio.confluent.connect.hdfs.string.StringFormat",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 174
      },
      "default": "io.confluent.connect.hdfs.avro.avroformatimportance: highthese classes are available by default:io.confluent.connect.hdfs.avro.avroformatio.confluent.connect.hdfs.json.jsonformatio.confluent.connect.hdfs.orc.orcformatio.confluent.connect.hdfs.parquet.parquetformatio.confluent.connect.hdfs.string.stringformat"
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 175,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: highImportantRotation strategy logic:In the following rotation strategies, the logic to flush files to storage is triggered when a new record arrives,afterthe defined interval or scheduled interval time. Flushing files is also triggered periodically by theoffset.flush.interval.mssetting defined in the Connect worker configuration. Theoffset.flush.interval.mssetting defaults to 60000 ms (60 seconds). If you enable the propertiesrotate.interval.msorrotate.schedule.interval.msand ingestion rate is low, you should setoffset.flush.interval.msto a smaller value so that records flush at the rotation interval (or close to the interval) .  Leaving theoffset.flush.interval.msset to the default 60 seconds may cause records to stay in an open file for longer than expected, if no new records get processed that trigger rotation.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 175
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 176,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. This configuration ensures that file commits are invoked every configured interval. This configuration is useful when data ingestion rate is low and the connector didn\u00e2\u0080\u0099t write enough messages to commit files. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 176
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 177,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This configuration ensures that file commits are invoked every configured interval. Time of commit will be adjusted to 00:00 of selected timezone. Commit will be performed at scheduled time regardless previous commit time or number of messages. This configuration is useful when you have to commit your data based on current server time, like at the beginning of every hour. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 177
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schemas.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 178,
      "display_name": "schemas.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 178
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 179,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: trueImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 179
      },
      "default": "trueimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 180,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 180
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 181,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000 (5 seconds)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 181
      },
      "default": "5000 (5 seconds)importance: low"
    },
    {
      "name": "shutdown.timeout.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 182,
      "display_name": "shutdown.timeout.ms",
      "documentation": "Clean shutdown timeout. This makes sure that asynchronous Hive metastore updates are completed during connector shutdown.Type: longDefault: 3000 (3 seconds)Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 182
      },
      "default": "3000 (3 seconds)importance: medium"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 183,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 183
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 184,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output files. Available values: null, deflate, snappy and bzip2 (Codec source is org.apache.avro.file.CodecFactory).Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 184
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "parquet.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 185,
      "display_name": "parquet.codec",
      "documentation": "The Parquet compression codec to be used for output files.Type: stringDefault: snappyValid Values: [none, snappy, gzip, brotli, lz4, lzo, zstd]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 185
      },
      "default": "snappyvalid values: [none, snappy, gzip, brotli, lz4, lzo, zstd]importance: low",
      "valid_values": [
        "none",
        "snappy",
        "gzip",
        "brotli",
        "lz4",
        "lzo",
        "zstd"
      ]
    },
    {
      "name": "storage.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 186,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classDefault: io.confluent.connect.hdfs.storage.HdfsStorageImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 186
      },
      "default": "io.confluent.connect.hdfs.storage.hdfsstorageimportance: high"
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 187,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Apache Kafka\u00c2\u00ae. Supports${topic}in the value,\nwhich will be replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction\nwithtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 187
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 188,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable. For example:hdfs://hostname:port.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 188
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 189,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 189
      },
      "default": "/importance: medium"
    },
    {
      "name": "topic.capture.groups.regex",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 190,
      "display_name": "topic.capture.groups.regex",
      "documentation": "A Java Pattern regex that matches the entire topic and captures values for substituting intotopics.dir. Indexed capture groups are accessible with${n}, where${0}refers to the whole match and${1}refers to the first capture group. Example config value of([a-zA-Z]*)_([a-zA-Z]*)will match topics that are two words delimited by an underscore and will capture each word separately. Withtopic.dir=${1}/${2}, a record from the topicexample_namewill be written into a subdirectory ofexample/name/. By default, this functionality is not enabled.Type: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 190
      },
      "default": "nullimportance: low"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 191,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. The following partitioners are available:DefaultPartitionerpreserves the Kafka partitions.DailyPartitionerpartitions data according to date.HourlyPartitionerpartitions data according to hour.FieldPartitionerpartitions the data to different directories according to the value of the partitioning field\nspecified inpartition.field.name.TimeBasedPartitionerpartitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 191
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 192,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field whenFieldPartitioneris used. You can enter multiple partitioning field names using comma-separated names.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 192
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 193,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 193
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 194,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 194
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 195,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 195
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 196,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Any timezone accepted by: classorg.joda.time.DateTimeZoneImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 196
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: any timezone accepted by: classorg.joda.time.datetimezoneimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 197,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 197
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 198,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 198
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "hive.integration",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 199,
      "display_name": "hive.integration",
      "documentation": "Configuration indicating whether to integrate with Hive when running the connector.Type: booleanDefault: falseImportance: highDependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 199
      },
      "default": "falseimportance: highdependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "dependents": [
        "hive.metastore.uris",
        "hive.conf.dir",
        "hive.home",
        "hive.database"
      ]
    },
    {
      "name": "hive.metastore.uris",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 200,
      "display_name": "hive.metastore.uris",
      "documentation": "The Hive metastore URIs, can be IP address or fully-qualified domain name and port of the metastore host.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 200
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 201,
      "display_name": "hive.conf.dir",
      "documentation": "Hive configuration directoryType: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 201
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 202,
      "display_name": "hive.home",
      "documentation": "Hive home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 202
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.database",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 203,
      "display_name": "hive.database",
      "documentation": "The database to use when the connector creates tables in Hive.Type: stringDefault: defaultImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 203
      },
      "default": "defaultimportance: high"
    },
    {
      "name": "hive.table.name",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 204,
      "display_name": "hive.table.name",
      "documentation": "The hive table name to use.\nIt must contain${topic}to inject the corresponding topic name.Type: stringDefault: \u00e2\u0080\u009c${topic}\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 204
      },
      "default": "\u00e2\u0080\u009c${topic}\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 205,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 205
      },
      "default": "noneimportance: high"
    },
    {
      "name": "hdfs.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 206,
      "display_name": "hdfs.url",
      "documentation": "The HDFS connection URL. This configuration has the format of hdfs://hostname:port and specifies the HDFS to export data to. This property is deprecated and will be removed in future releases. Usestore.urlinstead.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 206
      },
      "default": "nullimportance: high"
    },
    {
      "name": "hadoop.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 207,
      "display_name": "hadoop.conf.dir",
      "documentation": "The Hadoop configuration directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 207
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hadoop.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 208,
      "display_name": "hadoop.home",
      "documentation": "The Hadoop home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 208
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "logs.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 209,
      "display_name": "logs.dir",
      "documentation": "Top level directory to store the write ahead logs. Supports${topic}in the value, which will\nbe replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction withtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: logsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 209
      },
      "default": "logsimportance: high"
    },
    {
      "name": "hdfs.authentication.kerberos",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 210,
      "display_name": "hdfs.authentication.kerberos",
      "documentation": "Configuration indicating whether HDFS is using Kerberos for authentication.Type: booleanDefault: falseImportance: highDependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 210
      },
      "default": "falseimportance: highdependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "dependents": [
        "connect.hdfs.principal",
        "connect.hdfs.keytab",
        "hdfs.namenode.principal",
        "kerberos.ticket.renew.period.ms"
      ]
    },
    {
      "name": "connect.hdfs.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 211,
      "display_name": "connect.hdfs.principal",
      "documentation": "The principal name to load from the keytab for Kerberos authentication.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 211
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "connect.hdfs.keytab",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 212,
      "display_name": "connect.hdfs.keytab",
      "documentation": "The path to the keytab file for the HDFS connector principal. This keytab file should only be readable by the connector user.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 212
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hdfs.namenode.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 213,
      "display_name": "hdfs.namenode.principal",
      "documentation": "The Kerberos principal name for the HDFS Namenode. The format isnn/_HOST@REALM.TLD.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 213
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "kerberos.ticket.renew.period.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 214,
      "display_name": "kerberos.ticket.renew.period.ms",
      "documentation": "The period in milliseconds to renew the Kerberos ticket.Type: longDefault: 3600000 (1 hour)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 214
      },
      "default": "3600000 (1 hour)importance: low"
    },
    {
      "name": "format.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 215,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store. Format classes\nimplement theio.confluent.connect.storage.format.Formatinterface.Type: classDefault:io.confluent.connect.hdfs.avro.AvroFormatImportance: highThese classes are available by default:io.confluent.connect.hdfs.avro.AvroFormatio.confluent.connect.hdfs.json.JsonFormatio.confluent.connect.hdfs.orc.OrcFormatio.confluent.connect.hdfs.parquet.ParquetFormatio.confluent.connect.hdfs.string.StringFormat",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 215
      },
      "default": "io.confluent.connect.hdfs.avro.avroformatimportance: highthese classes are available by default:io.confluent.connect.hdfs.avro.avroformatio.confluent.connect.hdfs.json.jsonformatio.confluent.connect.hdfs.orc.orcformatio.confluent.connect.hdfs.parquet.parquetformatio.confluent.connect.hdfs.string.stringformat"
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 216,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: highImportantRotation strategy logic:In the following rotation strategies, the logic to flush files to storage is triggered when a new record arrives,afterthe defined interval or scheduled interval time. Flushing files is also triggered periodically by theoffset.flush.interval.mssetting defined in the Connect worker configuration. Theoffset.flush.interval.mssetting defaults to 60000 ms (60 seconds). If you enable the propertiesrotate.interval.msorrotate.schedule.interval.msand ingestion rate is low, you should setoffset.flush.interval.msto a smaller value so that records flush at the rotation interval (or close to the interval) .  Leaving theoffset.flush.interval.msset to the default 60 seconds may cause records to stay in an open file for longer than expected, if no new records get processed that trigger rotation.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 216
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 217,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. This configuration ensures that file commits are invoked every configured interval. This configuration is useful when data ingestion rate is low and the connector didn\u00e2\u0080\u0099t write enough messages to commit files. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 217
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 218,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This configuration ensures that file commits are invoked every configured interval. Time of commit will be adjusted to 00:00 of selected timezone. Commit will be performed at scheduled time regardless previous commit time or number of messages. This configuration is useful when you have to commit your data based on current server time, like at the beginning of every hour. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 218
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schemas.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 219,
      "display_name": "schemas.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 219
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 220,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: trueImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 220
      },
      "default": "trueimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 221,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 221
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 222,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000 (5 seconds)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 222
      },
      "default": "5000 (5 seconds)importance: low"
    },
    {
      "name": "shutdown.timeout.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 223,
      "display_name": "shutdown.timeout.ms",
      "documentation": "Clean shutdown timeout. This makes sure that asynchronous Hive metastore updates are completed during connector shutdown.Type: longDefault: 3000 (3 seconds)Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 223
      },
      "default": "3000 (3 seconds)importance: medium"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 224,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 224
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 225,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output files. Available values: null, deflate, snappy and bzip2 (Codec source is org.apache.avro.file.CodecFactory).Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 225
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "parquet.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 226,
      "display_name": "parquet.codec",
      "documentation": "The Parquet compression codec to be used for output files.Type: stringDefault: snappyValid Values: [none, snappy, gzip, brotli, lz4, lzo, zstd]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 226
      },
      "default": "snappyvalid values: [none, snappy, gzip, brotli, lz4, lzo, zstd]importance: low",
      "valid_values": [
        "none",
        "snappy",
        "gzip",
        "brotli",
        "lz4",
        "lzo",
        "zstd"
      ]
    },
    {
      "name": "storage.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 227,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classDefault: io.confluent.connect.hdfs.storage.HdfsStorageImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 227
      },
      "default": "io.confluent.connect.hdfs.storage.hdfsstorageimportance: high"
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 228,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Apache Kafka\u00c2\u00ae. Supports${topic}in the value,\nwhich will be replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction\nwithtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 228
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 229,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable. For example:hdfs://hostname:port.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 229
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 230,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 230
      },
      "default": "/importance: medium"
    },
    {
      "name": "topic.capture.groups.regex",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 231,
      "display_name": "topic.capture.groups.regex",
      "documentation": "A Java Pattern regex that matches the entire topic and captures values for substituting intotopics.dir. Indexed capture groups are accessible with${n}, where${0}refers to the whole match and${1}refers to the first capture group. Example config value of([a-zA-Z]*)_([a-zA-Z]*)will match topics that are two words delimited by an underscore and will capture each word separately. Withtopic.dir=${1}/${2}, a record from the topicexample_namewill be written into a subdirectory ofexample/name/. By default, this functionality is not enabled.Type: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 231
      },
      "default": "nullimportance: low"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 232,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. The following partitioners are available:DefaultPartitionerpreserves the Kafka partitions.DailyPartitionerpartitions data according to date.HourlyPartitionerpartitions data according to hour.FieldPartitionerpartitions the data to different directories according to the value of the partitioning field\nspecified inpartition.field.name.TimeBasedPartitionerpartitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 232
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 233,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field whenFieldPartitioneris used. You can enter multiple partitioning field names using comma-separated names.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 233
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 234,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 234
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 235,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 235
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 236,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 236
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 237,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Any timezone accepted by: classorg.joda.time.DateTimeZoneImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 237
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: any timezone accepted by: classorg.joda.time.datetimezoneimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 238,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 238
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 239,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 239
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "hive.integration",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 240,
      "display_name": "hive.integration",
      "documentation": "Configuration indicating whether to integrate with Hive when running the connector.Type: booleanDefault: falseImportance: highDependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 240
      },
      "default": "falseimportance: highdependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "dependents": [
        "hive.metastore.uris",
        "hive.conf.dir",
        "hive.home",
        "hive.database"
      ]
    },
    {
      "name": "hive.metastore.uris",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 241,
      "display_name": "hive.metastore.uris",
      "documentation": "The Hive metastore URIs, can be IP address or fully-qualified domain name and port of the metastore host.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 241
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 242,
      "display_name": "hive.conf.dir",
      "documentation": "Hive configuration directoryType: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 242
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 243,
      "display_name": "hive.home",
      "documentation": "Hive home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 243
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.database",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 244,
      "display_name": "hive.database",
      "documentation": "The database to use when the connector creates tables in Hive.Type: stringDefault: defaultImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 244
      },
      "default": "defaultimportance: high"
    },
    {
      "name": "hive.table.name",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 245,
      "display_name": "hive.table.name",
      "documentation": "The hive table name to use.\nIt must contain${topic}to inject the corresponding topic name.Type: stringDefault: \u00e2\u0080\u009c${topic}\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 245
      },
      "default": "\u00e2\u0080\u009c${topic}\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 246,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 246
      },
      "default": "noneimportance: high"
    },
    {
      "name": "hdfs.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 247,
      "display_name": "hdfs.url",
      "documentation": "The HDFS connection URL. This configuration has the format of hdfs://hostname:port and specifies the HDFS to export data to. This property is deprecated and will be removed in future releases. Usestore.urlinstead.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 247
      },
      "default": "nullimportance: high"
    },
    {
      "name": "hadoop.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 248,
      "display_name": "hadoop.conf.dir",
      "documentation": "The Hadoop configuration directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 248
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hadoop.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 249,
      "display_name": "hadoop.home",
      "documentation": "The Hadoop home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 249
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "logs.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 250,
      "display_name": "logs.dir",
      "documentation": "Top level directory to store the write ahead logs. Supports${topic}in the value, which will\nbe replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction withtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: logsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 250
      },
      "default": "logsimportance: high"
    },
    {
      "name": "hdfs.authentication.kerberos",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 251,
      "display_name": "hdfs.authentication.kerberos",
      "documentation": "Configuration indicating whether HDFS is using Kerberos for authentication.Type: booleanDefault: falseImportance: highDependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 251
      },
      "default": "falseimportance: highdependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "dependents": [
        "connect.hdfs.principal",
        "connect.hdfs.keytab",
        "hdfs.namenode.principal",
        "kerberos.ticket.renew.period.ms"
      ]
    },
    {
      "name": "connect.hdfs.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 252,
      "display_name": "connect.hdfs.principal",
      "documentation": "The principal name to load from the keytab for Kerberos authentication.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 252
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "connect.hdfs.keytab",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 253,
      "display_name": "connect.hdfs.keytab",
      "documentation": "The path to the keytab file for the HDFS connector principal. This keytab file should only be readable by the connector user.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 253
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hdfs.namenode.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 254,
      "display_name": "hdfs.namenode.principal",
      "documentation": "The Kerberos principal name for the HDFS Namenode. The format isnn/_HOST@REALM.TLD.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 254
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "kerberos.ticket.renew.period.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 255,
      "display_name": "kerberos.ticket.renew.period.ms",
      "documentation": "The period in milliseconds to renew the Kerberos ticket.Type: longDefault: 3600000 (1 hour)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 255
      },
      "default": "3600000 (1 hour)importance: low"
    },
    {
      "name": "format.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 256,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store. Format classes\nimplement theio.confluent.connect.storage.format.Formatinterface.Type: classDefault:io.confluent.connect.hdfs.avro.AvroFormatImportance: highThese classes are available by default:io.confluent.connect.hdfs.avro.AvroFormatio.confluent.connect.hdfs.json.JsonFormatio.confluent.connect.hdfs.orc.OrcFormatio.confluent.connect.hdfs.parquet.ParquetFormatio.confluent.connect.hdfs.string.StringFormat",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 256
      },
      "default": "io.confluent.connect.hdfs.avro.avroformatimportance: highthese classes are available by default:io.confluent.connect.hdfs.avro.avroformatio.confluent.connect.hdfs.json.jsonformatio.confluent.connect.hdfs.orc.orcformatio.confluent.connect.hdfs.parquet.parquetformatio.confluent.connect.hdfs.string.stringformat"
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 257,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: highImportantRotation strategy logic:In the following rotation strategies, the logic to flush files to storage is triggered when a new record arrives,afterthe defined interval or scheduled interval time. Flushing files is also triggered periodically by theoffset.flush.interval.mssetting defined in the Connect worker configuration. Theoffset.flush.interval.mssetting defaults to 60000 ms (60 seconds). If you enable the propertiesrotate.interval.msorrotate.schedule.interval.msand ingestion rate is low, you should setoffset.flush.interval.msto a smaller value so that records flush at the rotation interval (or close to the interval) .  Leaving theoffset.flush.interval.msset to the default 60 seconds may cause records to stay in an open file for longer than expected, if no new records get processed that trigger rotation.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 257
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 258,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. This configuration ensures that file commits are invoked every configured interval. This configuration is useful when data ingestion rate is low and the connector didn\u00e2\u0080\u0099t write enough messages to commit files. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 258
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 259,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This configuration ensures that file commits are invoked every configured interval. Time of commit will be adjusted to 00:00 of selected timezone. Commit will be performed at scheduled time regardless previous commit time or number of messages. This configuration is useful when you have to commit your data based on current server time, like at the beginning of every hour. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 259
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schemas.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 260,
      "display_name": "schemas.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 260
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 261,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: trueImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 261
      },
      "default": "trueimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 262,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 262
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 263,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000 (5 seconds)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 263
      },
      "default": "5000 (5 seconds)importance: low"
    },
    {
      "name": "shutdown.timeout.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 264,
      "display_name": "shutdown.timeout.ms",
      "documentation": "Clean shutdown timeout. This makes sure that asynchronous Hive metastore updates are completed during connector shutdown.Type: longDefault: 3000 (3 seconds)Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 264
      },
      "default": "3000 (3 seconds)importance: medium"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 265,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 265
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 266,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output files. Available values: null, deflate, snappy and bzip2 (Codec source is org.apache.avro.file.CodecFactory).Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 266
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "parquet.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 267,
      "display_name": "parquet.codec",
      "documentation": "The Parquet compression codec to be used for output files.Type: stringDefault: snappyValid Values: [none, snappy, gzip, brotli, lz4, lzo, zstd]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 267
      },
      "default": "snappyvalid values: [none, snappy, gzip, brotli, lz4, lzo, zstd]importance: low",
      "valid_values": [
        "none",
        "snappy",
        "gzip",
        "brotli",
        "lz4",
        "lzo",
        "zstd"
      ]
    },
    {
      "name": "storage.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 268,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classDefault: io.confluent.connect.hdfs.storage.HdfsStorageImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 268
      },
      "default": "io.confluent.connect.hdfs.storage.hdfsstorageimportance: high"
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 269,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Apache Kafka\u00c2\u00ae. Supports${topic}in the value,\nwhich will be replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction\nwithtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 269
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 270,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable. For example:hdfs://hostname:port.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 270
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 271,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 271
      },
      "default": "/importance: medium"
    },
    {
      "name": "topic.capture.groups.regex",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 272,
      "display_name": "topic.capture.groups.regex",
      "documentation": "A Java Pattern regex that matches the entire topic and captures values for substituting intotopics.dir. Indexed capture groups are accessible with${n}, where${0}refers to the whole match and${1}refers to the first capture group. Example config value of([a-zA-Z]*)_([a-zA-Z]*)will match topics that are two words delimited by an underscore and will capture each word separately. Withtopic.dir=${1}/${2}, a record from the topicexample_namewill be written into a subdirectory ofexample/name/. By default, this functionality is not enabled.Type: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 272
      },
      "default": "nullimportance: low"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 273,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. The following partitioners are available:DefaultPartitionerpreserves the Kafka partitions.DailyPartitionerpartitions data according to date.HourlyPartitionerpartitions data according to hour.FieldPartitionerpartitions the data to different directories according to the value of the partitioning field\nspecified inpartition.field.name.TimeBasedPartitionerpartitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 273
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 274,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field whenFieldPartitioneris used. You can enter multiple partitioning field names using comma-separated names.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 274
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 275,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 275
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 276,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 276
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 277,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 277
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 278,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Any timezone accepted by: classorg.joda.time.DateTimeZoneImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 278
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: any timezone accepted by: classorg.joda.time.datetimezoneimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 279,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 279
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 280,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 280
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "hive.integration",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 281,
      "display_name": "hive.integration",
      "documentation": "Configuration indicating whether to integrate with Hive when running the connector.Type: booleanDefault: falseImportance: highDependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 281
      },
      "default": "falseimportance: highdependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "dependents": [
        "hive.metastore.uris",
        "hive.conf.dir",
        "hive.home",
        "hive.database"
      ]
    },
    {
      "name": "hive.metastore.uris",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 282,
      "display_name": "hive.metastore.uris",
      "documentation": "The Hive metastore URIs, can be IP address or fully-qualified domain name and port of the metastore host.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 282
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 283,
      "display_name": "hive.conf.dir",
      "documentation": "Hive configuration directoryType: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 283
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 284,
      "display_name": "hive.home",
      "documentation": "Hive home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 284
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.database",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 285,
      "display_name": "hive.database",
      "documentation": "The database to use when the connector creates tables in Hive.Type: stringDefault: defaultImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 285
      },
      "default": "defaultimportance: high"
    },
    {
      "name": "hive.table.name",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 286,
      "display_name": "hive.table.name",
      "documentation": "The hive table name to use.\nIt must contain${topic}to inject the corresponding topic name.Type: stringDefault: \u00e2\u0080\u009c${topic}\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 286
      },
      "default": "\u00e2\u0080\u009c${topic}\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 287,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 287
      },
      "default": "noneimportance: high"
    },
    {
      "name": "hdfs.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 288,
      "display_name": "hdfs.url",
      "documentation": "The HDFS connection URL. This configuration has the format of hdfs://hostname:port and specifies the HDFS to export data to. This property is deprecated and will be removed in future releases. Usestore.urlinstead.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 288
      },
      "default": "nullimportance: high"
    },
    {
      "name": "hadoop.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 289,
      "display_name": "hadoop.conf.dir",
      "documentation": "The Hadoop configuration directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 289
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hadoop.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 290,
      "display_name": "hadoop.home",
      "documentation": "The Hadoop home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 290
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "logs.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 291,
      "display_name": "logs.dir",
      "documentation": "Top level directory to store the write ahead logs. Supports${topic}in the value, which will\nbe replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction withtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: logsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 291
      },
      "default": "logsimportance: high"
    },
    {
      "name": "hdfs.authentication.kerberos",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 292,
      "display_name": "hdfs.authentication.kerberos",
      "documentation": "Configuration indicating whether HDFS is using Kerberos for authentication.Type: booleanDefault: falseImportance: highDependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 292
      },
      "default": "falseimportance: highdependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "dependents": [
        "connect.hdfs.principal",
        "connect.hdfs.keytab",
        "hdfs.namenode.principal",
        "kerberos.ticket.renew.period.ms"
      ]
    },
    {
      "name": "connect.hdfs.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 293,
      "display_name": "connect.hdfs.principal",
      "documentation": "The principal name to load from the keytab for Kerberos authentication.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 293
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "connect.hdfs.keytab",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 294,
      "display_name": "connect.hdfs.keytab",
      "documentation": "The path to the keytab file for the HDFS connector principal. This keytab file should only be readable by the connector user.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 294
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hdfs.namenode.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 295,
      "display_name": "hdfs.namenode.principal",
      "documentation": "The Kerberos principal name for the HDFS Namenode. The format isnn/_HOST@REALM.TLD.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 295
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "kerberos.ticket.renew.period.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 296,
      "display_name": "kerberos.ticket.renew.period.ms",
      "documentation": "The period in milliseconds to renew the Kerberos ticket.Type: longDefault: 3600000 (1 hour)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 296
      },
      "default": "3600000 (1 hour)importance: low"
    },
    {
      "name": "format.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 297,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store. Format classes\nimplement theio.confluent.connect.storage.format.Formatinterface.Type: classDefault:io.confluent.connect.hdfs.avro.AvroFormatImportance: highThese classes are available by default:io.confluent.connect.hdfs.avro.AvroFormatio.confluent.connect.hdfs.json.JsonFormatio.confluent.connect.hdfs.orc.OrcFormatio.confluent.connect.hdfs.parquet.ParquetFormatio.confluent.connect.hdfs.string.StringFormat",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 297
      },
      "default": "io.confluent.connect.hdfs.avro.avroformatimportance: highthese classes are available by default:io.confluent.connect.hdfs.avro.avroformatio.confluent.connect.hdfs.json.jsonformatio.confluent.connect.hdfs.orc.orcformatio.confluent.connect.hdfs.parquet.parquetformatio.confluent.connect.hdfs.string.stringformat"
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 298,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: highImportantRotation strategy logic:In the following rotation strategies, the logic to flush files to storage is triggered when a new record arrives,afterthe defined interval or scheduled interval time. Flushing files is also triggered periodically by theoffset.flush.interval.mssetting defined in the Connect worker configuration. Theoffset.flush.interval.mssetting defaults to 60000 ms (60 seconds). If you enable the propertiesrotate.interval.msorrotate.schedule.interval.msand ingestion rate is low, you should setoffset.flush.interval.msto a smaller value so that records flush at the rotation interval (or close to the interval) .  Leaving theoffset.flush.interval.msset to the default 60 seconds may cause records to stay in an open file for longer than expected, if no new records get processed that trigger rotation.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 298
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 299,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. This configuration ensures that file commits are invoked every configured interval. This configuration is useful when data ingestion rate is low and the connector didn\u00e2\u0080\u0099t write enough messages to commit files. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 299
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 300,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This configuration ensures that file commits are invoked every configured interval. Time of commit will be adjusted to 00:00 of selected timezone. Commit will be performed at scheduled time regardless previous commit time or number of messages. This configuration is useful when you have to commit your data based on current server time, like at the beginning of every hour. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 300
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schemas.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 301,
      "display_name": "schemas.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 301
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 302,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: trueImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 302
      },
      "default": "trueimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 303,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 303
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 304,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000 (5 seconds)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 304
      },
      "default": "5000 (5 seconds)importance: low"
    },
    {
      "name": "shutdown.timeout.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 305,
      "display_name": "shutdown.timeout.ms",
      "documentation": "Clean shutdown timeout. This makes sure that asynchronous Hive metastore updates are completed during connector shutdown.Type: longDefault: 3000 (3 seconds)Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 305
      },
      "default": "3000 (3 seconds)importance: medium"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 306,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 306
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 307,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output files. Available values: null, deflate, snappy and bzip2 (Codec source is org.apache.avro.file.CodecFactory).Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 307
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "parquet.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 308,
      "display_name": "parquet.codec",
      "documentation": "The Parquet compression codec to be used for output files.Type: stringDefault: snappyValid Values: [none, snappy, gzip, brotli, lz4, lzo, zstd]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 308
      },
      "default": "snappyvalid values: [none, snappy, gzip, brotli, lz4, lzo, zstd]importance: low",
      "valid_values": [
        "none",
        "snappy",
        "gzip",
        "brotli",
        "lz4",
        "lzo",
        "zstd"
      ]
    },
    {
      "name": "storage.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 309,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classDefault: io.confluent.connect.hdfs.storage.HdfsStorageImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 309
      },
      "default": "io.confluent.connect.hdfs.storage.hdfsstorageimportance: high"
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 310,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Apache Kafka\u00c2\u00ae. Supports${topic}in the value,\nwhich will be replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction\nwithtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 310
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 311,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable. For example:hdfs://hostname:port.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 311
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 312,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 312
      },
      "default": "/importance: medium"
    },
    {
      "name": "topic.capture.groups.regex",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 313,
      "display_name": "topic.capture.groups.regex",
      "documentation": "A Java Pattern regex that matches the entire topic and captures values for substituting intotopics.dir. Indexed capture groups are accessible with${n}, where${0}refers to the whole match and${1}refers to the first capture group. Example config value of([a-zA-Z]*)_([a-zA-Z]*)will match topics that are two words delimited by an underscore and will capture each word separately. Withtopic.dir=${1}/${2}, a record from the topicexample_namewill be written into a subdirectory ofexample/name/. By default, this functionality is not enabled.Type: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 313
      },
      "default": "nullimportance: low"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 314,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. The following partitioners are available:DefaultPartitionerpreserves the Kafka partitions.DailyPartitionerpartitions data according to date.HourlyPartitionerpartitions data according to hour.FieldPartitionerpartitions the data to different directories according to the value of the partitioning field\nspecified inpartition.field.name.TimeBasedPartitionerpartitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 314
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 315,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field whenFieldPartitioneris used. You can enter multiple partitioning field names using comma-separated names.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 315
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 316,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 316
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 317,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 317
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 318,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 318
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 319,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Any timezone accepted by: classorg.joda.time.DateTimeZoneImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 319
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: any timezone accepted by: classorg.joda.time.datetimezoneimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 320,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 320
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 321,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 321
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "hive.integration",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 322,
      "display_name": "hive.integration",
      "documentation": "Configuration indicating whether to integrate with Hive when running the connector.Type: booleanDefault: falseImportance: highDependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 322
      },
      "default": "falseimportance: highdependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "dependents": [
        "hive.metastore.uris",
        "hive.conf.dir",
        "hive.home",
        "hive.database"
      ]
    },
    {
      "name": "hive.metastore.uris",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 323,
      "display_name": "hive.metastore.uris",
      "documentation": "The Hive metastore URIs, can be IP address or fully-qualified domain name and port of the metastore host.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 323
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 324,
      "display_name": "hive.conf.dir",
      "documentation": "Hive configuration directoryType: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 324
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 325,
      "display_name": "hive.home",
      "documentation": "Hive home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 325
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.database",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 326,
      "display_name": "hive.database",
      "documentation": "The database to use when the connector creates tables in Hive.Type: stringDefault: defaultImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 326
      },
      "default": "defaultimportance: high"
    },
    {
      "name": "hive.table.name",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 327,
      "display_name": "hive.table.name",
      "documentation": "The hive table name to use.\nIt must contain${topic}to inject the corresponding topic name.Type: stringDefault: \u00e2\u0080\u009c${topic}\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 327
      },
      "default": "\u00e2\u0080\u009c${topic}\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 328,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 328
      },
      "default": "noneimportance: high"
    },
    {
      "name": "hdfs.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 329,
      "display_name": "hdfs.url",
      "documentation": "The HDFS connection URL. This configuration has the format of hdfs://hostname:port and specifies the HDFS to export data to. This property is deprecated and will be removed in future releases. Usestore.urlinstead.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 329
      },
      "default": "nullimportance: high"
    },
    {
      "name": "hadoop.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 330,
      "display_name": "hadoop.conf.dir",
      "documentation": "The Hadoop configuration directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 330
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hadoop.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 331,
      "display_name": "hadoop.home",
      "documentation": "The Hadoop home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 331
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "logs.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 332,
      "display_name": "logs.dir",
      "documentation": "Top level directory to store the write ahead logs. Supports${topic}in the value, which will\nbe replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction withtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: logsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 332
      },
      "default": "logsimportance: high"
    },
    {
      "name": "hdfs.authentication.kerberos",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 333,
      "display_name": "hdfs.authentication.kerberos",
      "documentation": "Configuration indicating whether HDFS is using Kerberos for authentication.Type: booleanDefault: falseImportance: highDependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 333
      },
      "default": "falseimportance: highdependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "dependents": [
        "connect.hdfs.principal",
        "connect.hdfs.keytab",
        "hdfs.namenode.principal",
        "kerberos.ticket.renew.period.ms"
      ]
    },
    {
      "name": "connect.hdfs.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 334,
      "display_name": "connect.hdfs.principal",
      "documentation": "The principal name to load from the keytab for Kerberos authentication.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 334
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "connect.hdfs.keytab",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 335,
      "display_name": "connect.hdfs.keytab",
      "documentation": "The path to the keytab file for the HDFS connector principal. This keytab file should only be readable by the connector user.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 335
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hdfs.namenode.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 336,
      "display_name": "hdfs.namenode.principal",
      "documentation": "The Kerberos principal name for the HDFS Namenode. The format isnn/_HOST@REALM.TLD.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 336
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "kerberos.ticket.renew.period.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 337,
      "display_name": "kerberos.ticket.renew.period.ms",
      "documentation": "The period in milliseconds to renew the Kerberos ticket.Type: longDefault: 3600000 (1 hour)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 337
      },
      "default": "3600000 (1 hour)importance: low"
    },
    {
      "name": "format.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 338,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store. Format classes\nimplement theio.confluent.connect.storage.format.Formatinterface.Type: classDefault:io.confluent.connect.hdfs.avro.AvroFormatImportance: highThese classes are available by default:io.confluent.connect.hdfs.avro.AvroFormatio.confluent.connect.hdfs.json.JsonFormatio.confluent.connect.hdfs.orc.OrcFormatio.confluent.connect.hdfs.parquet.ParquetFormatio.confluent.connect.hdfs.string.StringFormat",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 338
      },
      "default": "io.confluent.connect.hdfs.avro.avroformatimportance: highthese classes are available by default:io.confluent.connect.hdfs.avro.avroformatio.confluent.connect.hdfs.json.jsonformatio.confluent.connect.hdfs.orc.orcformatio.confluent.connect.hdfs.parquet.parquetformatio.confluent.connect.hdfs.string.stringformat"
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 339,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: highImportantRotation strategy logic:In the following rotation strategies, the logic to flush files to storage is triggered when a new record arrives,afterthe defined interval or scheduled interval time. Flushing files is also triggered periodically by theoffset.flush.interval.mssetting defined in the Connect worker configuration. Theoffset.flush.interval.mssetting defaults to 60000 ms (60 seconds). If you enable the propertiesrotate.interval.msorrotate.schedule.interval.msand ingestion rate is low, you should setoffset.flush.interval.msto a smaller value so that records flush at the rotation interval (or close to the interval) .  Leaving theoffset.flush.interval.msset to the default 60 seconds may cause records to stay in an open file for longer than expected, if no new records get processed that trigger rotation.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 339
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 340,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. This configuration ensures that file commits are invoked every configured interval. This configuration is useful when data ingestion rate is low and the connector didn\u00e2\u0080\u0099t write enough messages to commit files. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 340
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 341,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This configuration ensures that file commits are invoked every configured interval. Time of commit will be adjusted to 00:00 of selected timezone. Commit will be performed at scheduled time regardless previous commit time or number of messages. This configuration is useful when you have to commit your data based on current server time, like at the beginning of every hour. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 341
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schemas.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 342,
      "display_name": "schemas.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 342
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 343,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: trueImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 343
      },
      "default": "trueimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 344,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 344
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 345,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000 (5 seconds)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 345
      },
      "default": "5000 (5 seconds)importance: low"
    },
    {
      "name": "shutdown.timeout.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 346,
      "display_name": "shutdown.timeout.ms",
      "documentation": "Clean shutdown timeout. This makes sure that asynchronous Hive metastore updates are completed during connector shutdown.Type: longDefault: 3000 (3 seconds)Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 346
      },
      "default": "3000 (3 seconds)importance: medium"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 347,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 347
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 348,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output files. Available values: null, deflate, snappy and bzip2 (Codec source is org.apache.avro.file.CodecFactory).Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 348
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "parquet.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 349,
      "display_name": "parquet.codec",
      "documentation": "The Parquet compression codec to be used for output files.Type: stringDefault: snappyValid Values: [none, snappy, gzip, brotli, lz4, lzo, zstd]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 349
      },
      "default": "snappyvalid values: [none, snappy, gzip, brotli, lz4, lzo, zstd]importance: low",
      "valid_values": [
        "none",
        "snappy",
        "gzip",
        "brotli",
        "lz4",
        "lzo",
        "zstd"
      ]
    },
    {
      "name": "storage.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 350,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classDefault: io.confluent.connect.hdfs.storage.HdfsStorageImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 350
      },
      "default": "io.confluent.connect.hdfs.storage.hdfsstorageimportance: high"
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 351,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Apache Kafka\u00c2\u00ae. Supports${topic}in the value,\nwhich will be replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction\nwithtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 351
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 352,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable. For example:hdfs://hostname:port.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 352
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 353,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 353
      },
      "default": "/importance: medium"
    },
    {
      "name": "topic.capture.groups.regex",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 354,
      "display_name": "topic.capture.groups.regex",
      "documentation": "A Java Pattern regex that matches the entire topic and captures values for substituting intotopics.dir. Indexed capture groups are accessible with${n}, where${0}refers to the whole match and${1}refers to the first capture group. Example config value of([a-zA-Z]*)_([a-zA-Z]*)will match topics that are two words delimited by an underscore and will capture each word separately. Withtopic.dir=${1}/${2}, a record from the topicexample_namewill be written into a subdirectory ofexample/name/. By default, this functionality is not enabled.Type: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 354
      },
      "default": "nullimportance: low"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 355,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. The following partitioners are available:DefaultPartitionerpreserves the Kafka partitions.DailyPartitionerpartitions data according to date.HourlyPartitionerpartitions data according to hour.FieldPartitionerpartitions the data to different directories according to the value of the partitioning field\nspecified inpartition.field.name.TimeBasedPartitionerpartitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 355
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 356,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field whenFieldPartitioneris used. You can enter multiple partitioning field names using comma-separated names.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 356
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 357,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 357
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 358,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 358
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 359,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 359
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 360,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Any timezone accepted by: classorg.joda.time.DateTimeZoneImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 360
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: any timezone accepted by: classorg.joda.time.datetimezoneimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 361,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 361
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "HDFS",
      "order_in_group": 362,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 362
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "hive.integration",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 363,
      "display_name": "hive.integration",
      "documentation": "Configuration indicating whether to integrate with Hive when running the connector.Type: booleanDefault: falseImportance: highDependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 363
      },
      "default": "falseimportance: highdependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "dependents": [
        "hive.metastore.uris",
        "hive.conf.dir",
        "hive.home",
        "hive.database"
      ]
    },
    {
      "name": "hive.metastore.uris",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 364,
      "display_name": "hive.metastore.uris",
      "documentation": "The Hive metastore URIs, can be IP address or fully-qualified domain name and port of the metastore host.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 364
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 365,
      "display_name": "hive.conf.dir",
      "documentation": "Hive configuration directoryType: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 365
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 366,
      "display_name": "hive.home",
      "documentation": "Hive home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 366
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.database",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 367,
      "display_name": "hive.database",
      "documentation": "The database to use when the connector creates tables in Hive.Type: stringDefault: defaultImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 367
      },
      "default": "defaultimportance: high"
    },
    {
      "name": "hive.table.name",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "HDFS",
      "order_in_group": 368,
      "display_name": "hive.table.name",
      "documentation": "The hive table name to use.\nIt must contain${topic}to inject the corresponding topic name.Type: stringDefault: \u00e2\u0080\u009c${topic}\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 368
      },
      "default": "\u00e2\u0080\u009c${topic}\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 369,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 369
      },
      "default": "noneimportance: high"
    },
    {
      "name": "hdfs.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 370,
      "display_name": "hdfs.url",
      "documentation": "The HDFS connection URL. This configuration has the format of hdfs://hostname:port and specifies the HDFS to export data to. This property is deprecated and will be removed in future releases. Usestore.urlinstead.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 370
      },
      "default": "nullimportance: high"
    },
    {
      "name": "hadoop.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 371,
      "display_name": "hadoop.conf.dir",
      "documentation": "The Hadoop configuration directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 371
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hadoop.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 372,
      "display_name": "hadoop.home",
      "documentation": "The Hadoop home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 372
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "logs.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "HDFS",
      "order_in_group": 373,
      "display_name": "logs.dir",
      "documentation": "Top level directory to store the write ahead logs. Supports${topic}in the value, which will\nbe replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction withtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: logsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 373
      },
      "default": "logsimportance: high"
    },
    {
      "name": "hdfs.authentication.kerberos",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Security",
      "order_in_group": 374,
      "display_name": "hdfs.authentication.kerberos",
      "documentation": "Configuration indicating whether HDFS is using Kerberos for authentication.Type: booleanDefault: falseImportance: highDependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 374
      },
      "default": "falseimportance: highdependents:connect.hdfs.principal,connect.hdfs.keytab,hdfs.namenode.principal,kerberos.ticket.renew.period.ms",
      "dependents": [
        "connect.hdfs.principal",
        "connect.hdfs.keytab",
        "hdfs.namenode.principal",
        "kerberos.ticket.renew.period.ms"
      ]
    },
    {
      "name": "connect.hdfs.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Security",
      "order_in_group": 375,
      "display_name": "connect.hdfs.principal",
      "documentation": "The principal name to load from the keytab for Kerberos authentication.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 375
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "connect.hdfs.keytab",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Security",
      "order_in_group": 376,
      "display_name": "connect.hdfs.keytab",
      "documentation": "The path to the keytab file for the HDFS connector principal. This keytab file should only be readable by the connector user.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 376
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hdfs.namenode.principal",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Security",
      "order_in_group": 377,
      "display_name": "hdfs.namenode.principal",
      "documentation": "The Kerberos principal name for the HDFS Namenode. The format isnn/_HOST@REALM.TLD.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 377
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "kerberos.ticket.renew.period.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Security",
      "order_in_group": 378,
      "display_name": "kerberos.ticket.renew.period.ms",
      "documentation": "The period in milliseconds to renew the Kerberos ticket.Type: longDefault: 3600000 (1 hour)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 378
      },
      "default": "3600000 (1 hour)importance: low"
    },
    {
      "name": "format.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 379,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store. Format classes\nimplement theio.confluent.connect.storage.format.Formatinterface.Type: classDefault:io.confluent.connect.hdfs.avro.AvroFormatImportance: highThese classes are available by default:io.confluent.connect.hdfs.avro.AvroFormatio.confluent.connect.hdfs.json.JsonFormatio.confluent.connect.hdfs.orc.OrcFormatio.confluent.connect.hdfs.parquet.ParquetFormatio.confluent.connect.hdfs.string.StringFormat",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 379
      },
      "default": "io.confluent.connect.hdfs.avro.avroformatimportance: highthese classes are available by default:io.confluent.connect.hdfs.avro.avroformatio.confluent.connect.hdfs.json.jsonformatio.confluent.connect.hdfs.orc.orcformatio.confluent.connect.hdfs.parquet.parquetformatio.confluent.connect.hdfs.string.stringformat"
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 380,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: highImportantRotation strategy logic:In the following rotation strategies, the logic to flush files to storage is triggered when a new record arrives,afterthe defined interval or scheduled interval time. Flushing files is also triggered periodically by theoffset.flush.interval.mssetting defined in the Connect worker configuration. Theoffset.flush.interval.mssetting defaults to 60000 ms (60 seconds). If you enable the propertiesrotate.interval.msorrotate.schedule.interval.msand ingestion rate is low, you should setoffset.flush.interval.msto a smaller value so that records flush at the rotation interval (or close to the interval) .  Leaving theoffset.flush.interval.msset to the default 60 seconds may cause records to stay in an open file for longer than expected, if no new records get processed that trigger rotation.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 380
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 381,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. This configuration ensures that file commits are invoked every configured interval. This configuration is useful when data ingestion rate is low and the connector didn\u00e2\u0080\u0099t write enough messages to commit files. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 381
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 382,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This configuration ensures that file commits are invoked every configured interval. Time of commit will be adjusted to 00:00 of selected timezone. Commit will be performed at scheduled time regardless previous commit time or number of messages. This configuration is useful when you have to commit your data based on current server time, like at the beginning of every hour. The default value -1 means that this feature is disabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 382
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schemas.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 383,
      "display_name": "schemas.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 383
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 384,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: trueImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 384
      },
      "default": "trueimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 385,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 385
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 386,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000 (5 seconds)Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 386
      },
      "default": "5000 (5 seconds)importance: low"
    },
    {
      "name": "shutdown.timeout.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 387,
      "display_name": "shutdown.timeout.ms",
      "documentation": "Clean shutdown timeout. This makes sure that asynchronous Hive metastore updates are completed during connector shutdown.Type: longDefault: 3000 (3 seconds)Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 387
      },
      "default": "3000 (3 seconds)importance: medium"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 388,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 388
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 389,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output files. Available values: null, deflate, snappy and bzip2 (Codec source is org.apache.avro.file.CodecFactory).Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 389
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "parquet.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 390,
      "display_name": "parquet.codec",
      "documentation": "The Parquet compression codec to be used for output files.Type: stringDefault: snappyValid Values: [none, snappy, gzip, brotli, lz4, lzo, zstd]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 390
      },
      "default": "snappyvalid values: [none, snappy, gzip, brotli, lz4, lzo, zstd]importance: low",
      "valid_values": [
        "none",
        "snappy",
        "gzip",
        "brotli",
        "lz4",
        "lzo",
        "zstd"
      ]
    },
    {
      "name": "storage.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Storage",
      "order_in_group": 391,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classDefault: io.confluent.connect.hdfs.storage.HdfsStorageImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 391
      },
      "default": "io.confluent.connect.hdfs.storage.hdfsstorageimportance: high"
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Storage",
      "order_in_group": 392,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Apache Kafka\u00c2\u00ae. Supports${topic}in the value,\nwhich will be replaced by the actual topic name. Supports${0}, \u00e2\u0080\u00a6,${n}in conjunction\nwithtopic.capture.groups.regex. For details, seetopic.capture.groups.regexconfiguration\ndocumentation.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 392
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Storage",
      "order_in_group": 393,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable. For example:hdfs://hostname:port.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 393
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Storage",
      "order_in_group": 394,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 394
      },
      "default": "/importance: medium"
    },
    {
      "name": "topic.capture.groups.regex",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Storage",
      "order_in_group": 395,
      "display_name": "topic.capture.groups.regex",
      "documentation": "A Java Pattern regex that matches the entire topic and captures values for substituting intotopics.dir. Indexed capture groups are accessible with${n}, where${0}refers to the whole match and${1}refers to the first capture group. Example config value of([a-zA-Z]*)_([a-zA-Z]*)will match topics that are two words delimited by an underscore and will capture each word separately. Withtopic.dir=${1}/${2}, a record from the topicexample_namewill be written into a subdirectory ofexample/name/. By default, this functionality is not enabled.Type: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 395
      },
      "default": "nullimportance: low"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Partitioner",
      "order_in_group": 396,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. The following partitioners are available:DefaultPartitionerpreserves the Kafka partitions.DailyPartitionerpartitions data according to date.HourlyPartitionerpartitions data according to hour.FieldPartitionerpartitions the data to different directories according to the value of the partitioning field\nspecified inpartition.field.name.TimeBasedPartitionerpartitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 396
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 397,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field whenFieldPartitioneris used. You can enter multiple partitioning field names using comma-separated names.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 397
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 398,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 398
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 399,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 399
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 400,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 400
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 401,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Any timezone accepted by: classorg.joda.time.DateTimeZoneImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 401
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: any timezone accepted by: classorg.joda.time.datetimezoneimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 402,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 402
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 403,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 403
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "hive.integration",
      "type": "BOOLEANDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Hive",
      "order_in_group": 404,
      "display_name": "hive.integration",
      "documentation": "Configuration indicating whether to integrate with Hive when running the connector.Type: booleanDefault: falseImportance: highDependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 404
      },
      "default": "falseimportance: highdependents:hive.metastore.uris,hive.conf.dir,hive.home,hive.database",
      "dependents": [
        "hive.metastore.uris",
        "hive.conf.dir",
        "hive.home",
        "hive.database"
      ]
    },
    {
      "name": "hive.metastore.uris",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Hive",
      "order_in_group": 405,
      "display_name": "hive.metastore.uris",
      "documentation": "The Hive metastore URIs, can be IP address or fully-qualified domain name and port of the metastore host.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 405
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.conf.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Hive",
      "order_in_group": 406,
      "display_name": "hive.conf.dir",
      "documentation": "Hive configuration directoryType: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 406
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.home",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Hive",
      "order_in_group": 407,
      "display_name": "hive.home",
      "documentation": "Hive home directory.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 407
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: high"
    },
    {
      "name": "hive.database",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Hive",
      "order_in_group": 408,
      "display_name": "hive.database",
      "documentation": "The database to use when the connector creates tables in Hive.Type: stringDefault: defaultImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 408
      },
      "default": "defaultimportance: high"
    },
    {
      "name": "hive.table.name",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Hive",
      "order_in_group": 409,
      "display_name": "hive.table.name",
      "documentation": "The hive table name to use.\nIt must contain${topic}to inject the corresponding topic name.Type: stringDefault: \u00e2\u0080\u009c${topic}\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 409
      },
      "default": "\u00e2\u0080\u009c${topic}\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Schema",
      "order_in_group": 410,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 410
      },
      "default": "noneimportance: high"
    },
    {
      "name": "Search by configuration property name",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 2,
      "display_name": "Search by configuration property name",
      "documentation": "Enter a string to search and filter by configuration property name.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 2
      }
    },
    {
      "name": "name",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 2,
      "display_name": "name",
      "documentation": "Globally unique name to use for this connector.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 2
      }
    },
    {
      "name": "connector.class",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 3,
      "display_name": "connector.class",
      "documentation": "Name or alias of the class for this connector. Must be a subclass of org.apache.kafka.connect.connector.Connector. If the connector is org.apache.kafka.connect.file.FileStreamSinkConnector, you can either specify this full name,  or use \u00e2\u0080\u009cFileStreamSink\u00e2\u0080\u009d or \u00e2\u0080\u009cFileStreamSinkConnector\u00e2\u0080\u009d to make the configuration a bit shorter",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 3
      }
    },
    {
      "name": "tasks.max",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 4,
      "display_name": "tasks.max",
      "documentation": "Maximum number of tasks to use for this connector.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 4
      }
    },
    {
      "name": "topics",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 5,
      "display_name": "topics",
      "documentation": "List of topics to consume, separated by commas",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 5
      }
    },
    {
      "name": "topics.regex",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 6,
      "display_name": "topics.regex",
      "documentation": "Regular expression giving topics to consume. Under the hood, the regex is compiled to ajava.util.regex.Pattern. Only one of topics or topics.regex should be specified.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 6
      }
    },
    {
      "name": "tasks.max.enforce",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 7,
      "display_name": "tasks.max.enforce",
      "documentation": "(Deprecated) Whether to enforce that the tasks.max property is respected by the connector. By default, connectors that generate too many tasks will fail, and existing sets of tasks that exceed the tasks.max property will also be failed. If this property is set to false, then connectors will be allowed to generate more than the maximum number of tasks, and existing sets of tasks that exceed the tasks.max property will be allowed to run. This property is deprecated and will be removed in an upcoming major release.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 7
      }
    },
    {
      "name": "key.converter",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 8,
      "display_name": "key.converter",
      "documentation": "Converter class used to convert between Kafka Connect format and the serialized form that is written to Kafka. This controls the format of the keys in messages written to or read from Kafka, and since this is independent of connectors it allows any connector to work with any serialization format. Examples of common formats include JSON and Avro.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 8
      }
    },
    {
      "name": "value.converter",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 9,
      "display_name": "value.converter",
      "documentation": "Converter class used to convert between Kafka Connect format and the serialized form that is written to Kafka. This controls the format of the values in messages written to or read from Kafka, and since this is independent of connectors it allows any connector to work with any serialization format. Examples of common formats include JSON and Avro.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 9
      }
    },
    {
      "name": "header.converter",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 10,
      "display_name": "header.converter",
      "documentation": "HeaderConverter class used to convert between Kafka Connect format and the serialized form that is written to Kafka. This controls the format of the header values in messages written to or read from Kafka, and since this is independent of connectors it allows any connector to work with any serialization format. Examples of common formats include JSON and Avro. By default, the SimpleHeaderConverter is used to serialize header values to strings and deserialize them by inferring the schemas.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 10
      }
    },
    {
      "name": "config.action.reload",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 11,
      "display_name": "config.action.reload",
      "documentation": "The action that Connect should take on the connector when changes in external configuration providers result in a change in the connector\u00e2\u0080\u0099s configuration properties. A value of \u00e2\u0080\u0098none\u00e2\u0080\u0099 indicates that Connect will do nothing. A value of \u00e2\u0080\u0098restart\u00e2\u0080\u0099 indicates that Connect should restart/reload the connector with the updated configuration properties.The restart may actually be scheduled in the future if the external configuration provider indicates that a configuration value will expire in the future.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 11
      }
    },
    {
      "name": "transforms",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 12,
      "display_name": "transforms",
      "documentation": "Aliases for the transformations to be applied to records.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 12
      }
    },
    {
      "name": "predicates",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 13,
      "display_name": "predicates",
      "documentation": "Aliases for the predicates used by transformations.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 13
      }
    },
    {
      "name": "errors.retry.timeout",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 14,
      "display_name": "errors.retry.timeout",
      "documentation": "The maximum duration in milliseconds that a failed operation will be reattempted. The default is 0, which means no retries will be attempted. Use -1 for infinite retries.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 14
      }
    },
    {
      "name": "errors.retry.delay.max.ms",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 15,
      "display_name": "errors.retry.delay.max.ms",
      "documentation": "The maximum duration in milliseconds between consecutive retry attempts. Jitter will be added to the delay once this limit is reached to prevent thundering herd issues.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 15
      }
    },
    {
      "name": "errors.tolerance",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 16,
      "display_name": "errors.tolerance",
      "documentation": "Behavior for tolerating errors during connector operation. \u00e2\u0080\u0098none\u00e2\u0080\u0099 is the default value and signals that any error will result in an immediate connector task failure; \u00e2\u0080\u0098all\u00e2\u0080\u0099 changes the behavior to skip over problematic records.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 16
      }
    },
    {
      "name": "errors.log.enable",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 17,
      "display_name": "errors.log.enable",
      "documentation": "If true, write each error and the details of the failed operation and problematic record to the Connect application log. This is \u00e2\u0080\u0098false\u00e2\u0080\u0099 by default, so that only errors that are not tolerated are reported.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 17
      }
    },
    {
      "name": "errors.log.include.messages",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 18,
      "display_name": "errors.log.include.messages",
      "documentation": "Whether to include in the log the Connect record that resulted in a failure. For sink records, the topic, partition, offset, and timestamp will be logged. For source records, the key and value (and their schemas), all headers, and the timestamp, Kafka topic, Kafka partition, source partition, and source offset will be logged. This is \u00e2\u0080\u0098false\u00e2\u0080\u0099 by default, which will prevent record keys, values, and headers from being written to log files.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 18
      }
    },
    {
      "name": "errors.deadletterqueue.topic.name",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 19,
      "display_name": "errors.deadletterqueue.topic.name",
      "documentation": "The name of the topic to be used as the dead letter queue (DLQ) for messages that result in an error when processed by this sink connector, or its transformations or converters. The topic name is blank by default, which means that no messages are to be recorded in the DLQ.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 19
      }
    },
    {
      "name": "errors.deadletterqueue.topic.replication.factor",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 20,
      "display_name": "errors.deadletterqueue.topic.replication.factor",
      "documentation": "Replication factor used to create the dead letter queue topic when it doesn\u00e2\u0080\u0099t already exist.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 20
      }
    },
    {
      "name": "errors.deadletterqueue.context.headers.enable",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 21,
      "display_name": "errors.deadletterqueue.context.headers.enable",
      "documentation": "If true, add headers containing error context to the messages written to the dead letter queue. To avoid clashing with headers from the original record, all error context header keys, all error context header keys will start with__connect.errors.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 21
      }
    }
  ]
}