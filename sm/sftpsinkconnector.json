{
  "template_id": "SftpSinkConnector",
  "connector_type": "SINK",
  "connector.class": "io.confluent.connect.sftp.SftpSinkConnector",
  "name": "{{.logicalClusterId}}",
  "imports": [],
  "group_order": [
    "Connector",
    "Schema",
    "SFTP",
    "Security",
    "Storage",
    "Partitioner",
    "CSFLE configuration",
    "Confluent Platform license",
    "Confluent license properties",
    "License topic configuration",
    "License topic ACLs",
    "Override Default Configuration Properties"
  ],
  "config_defs": [
    {
      "name": "format.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 1,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 1
      }
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 2,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 2
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 3,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. You can configure\nthis parameter so that the time interval is determined by using a timestamp\nextractor (for example, Kafka Record Time, Record Field, or Wall Clock\nextractor). When the first record is processed, a timestamp is set as the base\ntime. This is useful if you require exactly-once-semantics. This configuration\nensures that file commits are invoked at every configured interval. The\ndefault value-1indicates that this \u00e2\u0080\u009d feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 3
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 4,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This\nconfiguration ensures that file commits are invoked at every configured\ninterval. Time of commit will be adjusted to 00:00 the selected timezone. The\ncommit will be performed at the scheduled time, regardless of the previous\ncommit time or number of messages. This configuration is useful when you\nhave to commit your data based on current server time, for example at the\nbeginning of every hour. The default value-1means that this feature is\ndisabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 4
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schema.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 5,
      "display_name": "schema.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 5
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 6,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: falseImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 6
      },
      "default": "falseimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 7,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 7
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 8,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Kafka connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 8
      },
      "default": "5000importance: low"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 9,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 9
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 10,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output  files. Available values: null, deflate, snappy and bzip2 (CodecSource is org.apache.avro.file.CodecFactory)Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 10
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 11,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 11
      },
      "default": "noneimportance: high"
    },
    {
      "name": "sftp.host",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 12,
      "display_name": "sftp.host",
      "documentation": "Sftp host to connect withType: stringDefault: 127.0.0.1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 12
      },
      "default": "127.0.0.1importance: high"
    },
    {
      "name": "sftp.port",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 13,
      "display_name": "sftp.port",
      "documentation": "Port number of SFTP serverType: intDefault: 22Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 13
      },
      "default": "22importance: medium"
    },
    {
      "name": "sftp.username",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 14,
      "display_name": "sftp.username",
      "documentation": "Username for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 14
      }
    },
    {
      "name": "sftp.password",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 15,
      "display_name": "sftp.password",
      "documentation": "Password for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 15
      }
    },
    {
      "name": "sftp.proxy.url",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 16,
      "display_name": "sftp.proxy.url",
      "documentation": "Proxy url for sftp connection.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 16
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "proxy.username",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 17,
      "display_name": "proxy.username",
      "documentation": "Proxy username for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 17
      },
      "default": "nullimportance: low"
    },
    {
      "name": "proxy.password",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 18,
      "display_name": "proxy.password",
      "documentation": "Proxy password for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 18
      },
      "default": "nullimportance: low"
    },
    {
      "name": "sftp.compression.type",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 19,
      "display_name": "sftp.compression.type",
      "documentation": "Compression type for file written to sftp. Applied when using JsonFormat or ByteArrayFormat. Available values: none, gzip.Type: stringDefault: noneImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 19
      },
      "default": "noneimportance: low"
    },
    {
      "name": "sftp.working.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 20,
      "display_name": "sftp.working.dir",
      "documentation": "Home directory on SFTP server.This will be the top most directory that will contain all the filesType: stringDefault: /homeImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 20
      },
      "default": "/homeimportance: high"
    },
    {
      "name": "tls.private.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 21,
      "display_name": "tls.private.key",
      "documentation": "Private key that will be used for public-key authentication. When\nauthenticating with SSL:Use a non-empty passphrase.Replace private key newlines with'\\r\\n'.For example:RSA_PRIVATE_KEY=$(awk '{printf \"%s\\\\r\\\\n\", $0}' ssh_host_rsa_key)Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 21
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.public.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 22,
      "display_name": "tls.public.key",
      "documentation": "Public key that will be used to decrypt the data encrypted with the private\nkey.Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 22
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.passphrase",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 23,
      "display_name": "tls.passphrase",
      "documentation": "Passphrase that will be used to decrypt the private key if the given private\nkey is encrypted.Type: passwordDefault: [hidden]Importance: lowImportantThe SFTP Sink connector will fail iftls.passphraseis empty.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 23
      },
      "default": "[hidden]importance: lowimportantthe sftp sink connector will fail iftls.passphraseis empty."
    },
    {
      "name": "tls.pemfile",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 24,
      "display_name": "tls.pemfile",
      "documentation": "Path to pemfile.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 24
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "storage.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 25,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 25
      }
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 26,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Kafka.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 26
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 27,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 27
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 28,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 28
      },
      "default": "/importance: medium"
    },
    {
      "name": "file.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 29,
      "display_name": "file.delim",
      "documentation": "File delimiter patternType: stringDefault: +Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 29
      },
      "default": "+importance: medium"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 30,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. You can useDefaultPartitioner, which preserves the Kafka partitions;FieldPartitioner, which partitions the data to different directories according to the value of the partitioning field specified inpartition.field.name;TimeBasedPartitioner, which partitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 30
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 31,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field when FieldPartitioner is used.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 31
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 32,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 32
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 33,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 33
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 34,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 34
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 35,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 35
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 36,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 36
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 37,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 37
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "confluent.topic.bootstrap.servers",
      "type": "LISTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 38,
      "display_name": "confluent.topic.bootstrap.servers",
      "documentation": "A list of host/port pairs to use for establishing the initial connection to the Kafka cluster used for licensing. All servers in the cluster will be discovered from the initial connection. This list should be in the form <code>host1:port1,host2:port2,\u00e2\u0080\u00a6</code>. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).Type: listImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 38
      }
    },
    {
      "name": "confluent.topic",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 39,
      "display_name": "confluent.topic",
      "documentation": "Name of the Kafka topic used for Confluent Platform configuration, including licensing information.Type: stringDefault: _confluent-commandImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 39
      },
      "default": "_confluent-commandimportance: low"
    },
    {
      "name": "confluent.topic.replication.factor",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 40,
      "display_name": "confluent.topic.replication.factor",
      "documentation": "The replication factor for the Kafka topic used for Confluent Platform configuration, including licensing information. This is used only if the topic does not already exist, and the default of 3 is appropriate for production use. If you are using a development environment with less than 3 brokers, you must set this to the number of brokers (often 1).Type: intDefault: 3Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 40
      },
      "default": "3importance: low"
    },
    {
      "name": "confluent.license",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 41,
      "display_name": "confluent.license",
      "documentation": "Confluent issues enterprise license keys to each subscriber. The license key is text that you can copy and\npaste as the value forconfluent.license. A trial license allows using the connector for a 30-day trial period. A developer license allows using the connector indefinitely for single-broker development environments.If you are a subscriber, contact Confluent Support for more information.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Confluent Platform licenseImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 41
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: confluent platform licenseimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 42,
      "display_name": "confluent.topic.ssl.truststore.location",
      "documentation": "The location of the trust store file.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 42
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 43,
      "display_name": "confluent.topic.ssl.truststore.password",
      "documentation": "The password for the trust store file. If a password is not set access to the truststore is still available, but\nintegrity checking is disabled.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 43
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 44,
      "display_name": "confluent.topic.ssl.keystore.location",
      "documentation": "The location of the key store file. This is optional for client and can be used for two-way authentication for client.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 44
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 45,
      "display_name": "confluent.topic.ssl.keystore.password",
      "documentation": "The store password for the key store file. This is optional for client and only needed if ssl.keystore.location is configured.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 45
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.key.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 46,
      "display_name": "confluent.topic.ssl.key.password",
      "documentation": "The password of the private key in the key store file. This is optional for client.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 46
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.security.protocol",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 47,
      "display_name": "confluent.topic.security.protocol",
      "documentation": "Protocol used to communicate with brokers. Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.Type: stringDefault: \u00e2\u0080\u009cPLAINTEXT\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 47
      },
      "default": "\u00e2\u0080\u009cplaintext\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "format.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 48,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 48
      }
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 49,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 49
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 50,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. You can configure\nthis parameter so that the time interval is determined by using a timestamp\nextractor (for example, Kafka Record Time, Record Field, or Wall Clock\nextractor). When the first record is processed, a timestamp is set as the base\ntime. This is useful if you require exactly-once-semantics. This configuration\nensures that file commits are invoked at every configured interval. The\ndefault value-1indicates that this \u00e2\u0080\u009d feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 50
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 51,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This\nconfiguration ensures that file commits are invoked at every configured\ninterval. Time of commit will be adjusted to 00:00 the selected timezone. The\ncommit will be performed at the scheduled time, regardless of the previous\ncommit time or number of messages. This configuration is useful when you\nhave to commit your data based on current server time, for example at the\nbeginning of every hour. The default value-1means that this feature is\ndisabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 51
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schema.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 52,
      "display_name": "schema.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 52
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 53,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: falseImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 53
      },
      "default": "falseimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 54,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 54
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 55,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Kafka connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 55
      },
      "default": "5000importance: low"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 56,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 56
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 57,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output  files. Available values: null, deflate, snappy and bzip2 (CodecSource is org.apache.avro.file.CodecFactory)Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 57
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 58,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 58
      },
      "default": "noneimportance: high"
    },
    {
      "name": "sftp.host",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 59,
      "display_name": "sftp.host",
      "documentation": "Sftp host to connect withType: stringDefault: 127.0.0.1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 59
      },
      "default": "127.0.0.1importance: high"
    },
    {
      "name": "sftp.port",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 60,
      "display_name": "sftp.port",
      "documentation": "Port number of SFTP serverType: intDefault: 22Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 60
      },
      "default": "22importance: medium"
    },
    {
      "name": "sftp.username",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 61,
      "display_name": "sftp.username",
      "documentation": "Username for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 61
      }
    },
    {
      "name": "sftp.password",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 62,
      "display_name": "sftp.password",
      "documentation": "Password for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 62
      }
    },
    {
      "name": "sftp.proxy.url",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 63,
      "display_name": "sftp.proxy.url",
      "documentation": "Proxy url for sftp connection.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 63
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "proxy.username",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 64,
      "display_name": "proxy.username",
      "documentation": "Proxy username for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 64
      },
      "default": "nullimportance: low"
    },
    {
      "name": "proxy.password",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 65,
      "display_name": "proxy.password",
      "documentation": "Proxy password for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 65
      },
      "default": "nullimportance: low"
    },
    {
      "name": "sftp.compression.type",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 66,
      "display_name": "sftp.compression.type",
      "documentation": "Compression type for file written to sftp. Applied when using JsonFormat or ByteArrayFormat. Available values: none, gzip.Type: stringDefault: noneImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 66
      },
      "default": "noneimportance: low"
    },
    {
      "name": "sftp.working.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 67,
      "display_name": "sftp.working.dir",
      "documentation": "Home directory on SFTP server.This will be the top most directory that will contain all the filesType: stringDefault: /homeImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 67
      },
      "default": "/homeimportance: high"
    },
    {
      "name": "tls.private.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 68,
      "display_name": "tls.private.key",
      "documentation": "Private key that will be used for public-key authentication. When\nauthenticating with SSL:Use a non-empty passphrase.Replace private key newlines with'\\r\\n'.For example:RSA_PRIVATE_KEY=$(awk '{printf \"%s\\\\r\\\\n\", $0}' ssh_host_rsa_key)Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 68
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.public.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 69,
      "display_name": "tls.public.key",
      "documentation": "Public key that will be used to decrypt the data encrypted with the private\nkey.Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 69
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.passphrase",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 70,
      "display_name": "tls.passphrase",
      "documentation": "Passphrase that will be used to decrypt the private key if the given private\nkey is encrypted.Type: passwordDefault: [hidden]Importance: lowImportantThe SFTP Sink connector will fail iftls.passphraseis empty.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 70
      },
      "default": "[hidden]importance: lowimportantthe sftp sink connector will fail iftls.passphraseis empty."
    },
    {
      "name": "tls.pemfile",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 71,
      "display_name": "tls.pemfile",
      "documentation": "Path to pemfile.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 71
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "storage.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 72,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 72
      }
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 73,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Kafka.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 73
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 74,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 74
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 75,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 75
      },
      "default": "/importance: medium"
    },
    {
      "name": "file.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 76,
      "display_name": "file.delim",
      "documentation": "File delimiter patternType: stringDefault: +Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 76
      },
      "default": "+importance: medium"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 77,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. You can useDefaultPartitioner, which preserves the Kafka partitions;FieldPartitioner, which partitions the data to different directories according to the value of the partitioning field specified inpartition.field.name;TimeBasedPartitioner, which partitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 77
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 78,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field when FieldPartitioner is used.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 78
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 79,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 79
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 80,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 80
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 81,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 81
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 82,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 82
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 83,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 83
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 84,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 84
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "confluent.topic.bootstrap.servers",
      "type": "LISTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 85,
      "display_name": "confluent.topic.bootstrap.servers",
      "documentation": "A list of host/port pairs to use for establishing the initial connection to the Kafka cluster used for licensing. All servers in the cluster will be discovered from the initial connection. This list should be in the form <code>host1:port1,host2:port2,\u00e2\u0080\u00a6</code>. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).Type: listImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 85
      }
    },
    {
      "name": "confluent.topic",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 86,
      "display_name": "confluent.topic",
      "documentation": "Name of the Kafka topic used for Confluent Platform configuration, including licensing information.Type: stringDefault: _confluent-commandImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 86
      },
      "default": "_confluent-commandimportance: low"
    },
    {
      "name": "confluent.topic.replication.factor",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 87,
      "display_name": "confluent.topic.replication.factor",
      "documentation": "The replication factor for the Kafka topic used for Confluent Platform configuration, including licensing information. This is used only if the topic does not already exist, and the default of 3 is appropriate for production use. If you are using a development environment with less than 3 brokers, you must set this to the number of brokers (often 1).Type: intDefault: 3Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 87
      },
      "default": "3importance: low"
    },
    {
      "name": "confluent.license",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 88,
      "display_name": "confluent.license",
      "documentation": "Confluent issues enterprise license keys to each subscriber. The license key is text that you can copy and\npaste as the value forconfluent.license. A trial license allows using the connector for a 30-day trial period. A developer license allows using the connector indefinitely for single-broker development environments.If you are a subscriber, contact Confluent Support for more information.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Confluent Platform licenseImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 88
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: confluent platform licenseimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 89,
      "display_name": "confluent.topic.ssl.truststore.location",
      "documentation": "The location of the trust store file.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 89
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 90,
      "display_name": "confluent.topic.ssl.truststore.password",
      "documentation": "The password for the trust store file. If a password is not set access to the truststore is still available, but\nintegrity checking is disabled.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 90
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 91,
      "display_name": "confluent.topic.ssl.keystore.location",
      "documentation": "The location of the key store file. This is optional for client and can be used for two-way authentication for client.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 91
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 92,
      "display_name": "confluent.topic.ssl.keystore.password",
      "documentation": "The store password for the key store file. This is optional for client and only needed if ssl.keystore.location is configured.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 92
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.key.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 93,
      "display_name": "confluent.topic.ssl.key.password",
      "documentation": "The password of the private key in the key store file. This is optional for client.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 93
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.security.protocol",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 94,
      "display_name": "confluent.topic.security.protocol",
      "documentation": "Protocol used to communicate with brokers. Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.Type: stringDefault: \u00e2\u0080\u009cPLAINTEXT\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 94
      },
      "default": "\u00e2\u0080\u009cplaintext\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "format.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 95,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 95
      }
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 96,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 96
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 97,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. You can configure\nthis parameter so that the time interval is determined by using a timestamp\nextractor (for example, Kafka Record Time, Record Field, or Wall Clock\nextractor). When the first record is processed, a timestamp is set as the base\ntime. This is useful if you require exactly-once-semantics. This configuration\nensures that file commits are invoked at every configured interval. The\ndefault value-1indicates that this \u00e2\u0080\u009d feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 97
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 98,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This\nconfiguration ensures that file commits are invoked at every configured\ninterval. Time of commit will be adjusted to 00:00 the selected timezone. The\ncommit will be performed at the scheduled time, regardless of the previous\ncommit time or number of messages. This configuration is useful when you\nhave to commit your data based on current server time, for example at the\nbeginning of every hour. The default value-1means that this feature is\ndisabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 98
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schema.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 99,
      "display_name": "schema.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 99
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 100,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: falseImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 100
      },
      "default": "falseimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 101,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 101
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 102,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Kafka connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 102
      },
      "default": "5000importance: low"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 103,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 103
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 104,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output  files. Available values: null, deflate, snappy and bzip2 (CodecSource is org.apache.avro.file.CodecFactory)Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 104
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 105,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 105
      },
      "default": "noneimportance: high"
    },
    {
      "name": "sftp.host",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 106,
      "display_name": "sftp.host",
      "documentation": "Sftp host to connect withType: stringDefault: 127.0.0.1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 106
      },
      "default": "127.0.0.1importance: high"
    },
    {
      "name": "sftp.port",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 107,
      "display_name": "sftp.port",
      "documentation": "Port number of SFTP serverType: intDefault: 22Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 107
      },
      "default": "22importance: medium"
    },
    {
      "name": "sftp.username",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 108,
      "display_name": "sftp.username",
      "documentation": "Username for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 108
      }
    },
    {
      "name": "sftp.password",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 109,
      "display_name": "sftp.password",
      "documentation": "Password for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 109
      }
    },
    {
      "name": "sftp.proxy.url",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 110,
      "display_name": "sftp.proxy.url",
      "documentation": "Proxy url for sftp connection.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 110
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "proxy.username",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 111,
      "display_name": "proxy.username",
      "documentation": "Proxy username for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 111
      },
      "default": "nullimportance: low"
    },
    {
      "name": "proxy.password",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 112,
      "display_name": "proxy.password",
      "documentation": "Proxy password for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 112
      },
      "default": "nullimportance: low"
    },
    {
      "name": "sftp.compression.type",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 113,
      "display_name": "sftp.compression.type",
      "documentation": "Compression type for file written to sftp. Applied when using JsonFormat or ByteArrayFormat. Available values: none, gzip.Type: stringDefault: noneImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 113
      },
      "default": "noneimportance: low"
    },
    {
      "name": "sftp.working.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 114,
      "display_name": "sftp.working.dir",
      "documentation": "Home directory on SFTP server.This will be the top most directory that will contain all the filesType: stringDefault: /homeImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 114
      },
      "default": "/homeimportance: high"
    },
    {
      "name": "tls.private.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 115,
      "display_name": "tls.private.key",
      "documentation": "Private key that will be used for public-key authentication. When\nauthenticating with SSL:Use a non-empty passphrase.Replace private key newlines with'\\r\\n'.For example:RSA_PRIVATE_KEY=$(awk '{printf \"%s\\\\r\\\\n\", $0}' ssh_host_rsa_key)Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 115
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.public.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 116,
      "display_name": "tls.public.key",
      "documentation": "Public key that will be used to decrypt the data encrypted with the private\nkey.Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 116
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.passphrase",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 117,
      "display_name": "tls.passphrase",
      "documentation": "Passphrase that will be used to decrypt the private key if the given private\nkey is encrypted.Type: passwordDefault: [hidden]Importance: lowImportantThe SFTP Sink connector will fail iftls.passphraseis empty.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 117
      },
      "default": "[hidden]importance: lowimportantthe sftp sink connector will fail iftls.passphraseis empty."
    },
    {
      "name": "tls.pemfile",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 118,
      "display_name": "tls.pemfile",
      "documentation": "Path to pemfile.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 118
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "storage.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 119,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 119
      }
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 120,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Kafka.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 120
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 121,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 121
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 122,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 122
      },
      "default": "/importance: medium"
    },
    {
      "name": "file.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 123,
      "display_name": "file.delim",
      "documentation": "File delimiter patternType: stringDefault: +Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 123
      },
      "default": "+importance: medium"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 124,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. You can useDefaultPartitioner, which preserves the Kafka partitions;FieldPartitioner, which partitions the data to different directories according to the value of the partitioning field specified inpartition.field.name;TimeBasedPartitioner, which partitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 124
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 125,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field when FieldPartitioner is used.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 125
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 126,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 126
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 127,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 127
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 128,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 128
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 129,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 129
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 130,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 130
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 131,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 131
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "confluent.topic.bootstrap.servers",
      "type": "LISTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 132,
      "display_name": "confluent.topic.bootstrap.servers",
      "documentation": "A list of host/port pairs to use for establishing the initial connection to the Kafka cluster used for licensing. All servers in the cluster will be discovered from the initial connection. This list should be in the form <code>host1:port1,host2:port2,\u00e2\u0080\u00a6</code>. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).Type: listImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 132
      }
    },
    {
      "name": "confluent.topic",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 133,
      "display_name": "confluent.topic",
      "documentation": "Name of the Kafka topic used for Confluent Platform configuration, including licensing information.Type: stringDefault: _confluent-commandImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 133
      },
      "default": "_confluent-commandimportance: low"
    },
    {
      "name": "confluent.topic.replication.factor",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 134,
      "display_name": "confluent.topic.replication.factor",
      "documentation": "The replication factor for the Kafka topic used for Confluent Platform configuration, including licensing information. This is used only if the topic does not already exist, and the default of 3 is appropriate for production use. If you are using a development environment with less than 3 brokers, you must set this to the number of brokers (often 1).Type: intDefault: 3Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 134
      },
      "default": "3importance: low"
    },
    {
      "name": "confluent.license",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 135,
      "display_name": "confluent.license",
      "documentation": "Confluent issues enterprise license keys to each subscriber. The license key is text that you can copy and\npaste as the value forconfluent.license. A trial license allows using the connector for a 30-day trial period. A developer license allows using the connector indefinitely for single-broker development environments.If you are a subscriber, contact Confluent Support for more information.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Confluent Platform licenseImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 135
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: confluent platform licenseimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 136,
      "display_name": "confluent.topic.ssl.truststore.location",
      "documentation": "The location of the trust store file.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 136
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 137,
      "display_name": "confluent.topic.ssl.truststore.password",
      "documentation": "The password for the trust store file. If a password is not set access to the truststore is still available, but\nintegrity checking is disabled.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 137
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 138,
      "display_name": "confluent.topic.ssl.keystore.location",
      "documentation": "The location of the key store file. This is optional for client and can be used for two-way authentication for client.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 138
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 139,
      "display_name": "confluent.topic.ssl.keystore.password",
      "documentation": "The store password for the key store file. This is optional for client and only needed if ssl.keystore.location is configured.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 139
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.key.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 140,
      "display_name": "confluent.topic.ssl.key.password",
      "documentation": "The password of the private key in the key store file. This is optional for client.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 140
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.security.protocol",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 141,
      "display_name": "confluent.topic.security.protocol",
      "documentation": "Protocol used to communicate with brokers. Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.Type: stringDefault: \u00e2\u0080\u009cPLAINTEXT\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 141
      },
      "default": "\u00e2\u0080\u009cplaintext\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "format.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 142,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 142
      }
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 143,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 143
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 144,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. You can configure\nthis parameter so that the time interval is determined by using a timestamp\nextractor (for example, Kafka Record Time, Record Field, or Wall Clock\nextractor). When the first record is processed, a timestamp is set as the base\ntime. This is useful if you require exactly-once-semantics. This configuration\nensures that file commits are invoked at every configured interval. The\ndefault value-1indicates that this \u00e2\u0080\u009d feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 144
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 145,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This\nconfiguration ensures that file commits are invoked at every configured\ninterval. Time of commit will be adjusted to 00:00 the selected timezone. The\ncommit will be performed at the scheduled time, regardless of the previous\ncommit time or number of messages. This configuration is useful when you\nhave to commit your data based on current server time, for example at the\nbeginning of every hour. The default value-1means that this feature is\ndisabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 145
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schema.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 146,
      "display_name": "schema.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 146
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 147,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: falseImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 147
      },
      "default": "falseimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 148,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 148
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 149,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Kafka connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 149
      },
      "default": "5000importance: low"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 150,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 150
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 151,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output  files. Available values: null, deflate, snappy and bzip2 (CodecSource is org.apache.avro.file.CodecFactory)Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 151
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 152,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 152
      },
      "default": "noneimportance: high"
    },
    {
      "name": "sftp.host",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 153,
      "display_name": "sftp.host",
      "documentation": "Sftp host to connect withType: stringDefault: 127.0.0.1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 153
      },
      "default": "127.0.0.1importance: high"
    },
    {
      "name": "sftp.port",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 154,
      "display_name": "sftp.port",
      "documentation": "Port number of SFTP serverType: intDefault: 22Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 154
      },
      "default": "22importance: medium"
    },
    {
      "name": "sftp.username",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 155,
      "display_name": "sftp.username",
      "documentation": "Username for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 155
      }
    },
    {
      "name": "sftp.password",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 156,
      "display_name": "sftp.password",
      "documentation": "Password for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 156
      }
    },
    {
      "name": "sftp.proxy.url",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 157,
      "display_name": "sftp.proxy.url",
      "documentation": "Proxy url for sftp connection.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 157
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "proxy.username",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 158,
      "display_name": "proxy.username",
      "documentation": "Proxy username for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 158
      },
      "default": "nullimportance: low"
    },
    {
      "name": "proxy.password",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 159,
      "display_name": "proxy.password",
      "documentation": "Proxy password for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 159
      },
      "default": "nullimportance: low"
    },
    {
      "name": "sftp.compression.type",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 160,
      "display_name": "sftp.compression.type",
      "documentation": "Compression type for file written to sftp. Applied when using JsonFormat or ByteArrayFormat. Available values: none, gzip.Type: stringDefault: noneImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 160
      },
      "default": "noneimportance: low"
    },
    {
      "name": "sftp.working.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 161,
      "display_name": "sftp.working.dir",
      "documentation": "Home directory on SFTP server.This will be the top most directory that will contain all the filesType: stringDefault: /homeImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 161
      },
      "default": "/homeimportance: high"
    },
    {
      "name": "tls.private.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 162,
      "display_name": "tls.private.key",
      "documentation": "Private key that will be used for public-key authentication. When\nauthenticating with SSL:Use a non-empty passphrase.Replace private key newlines with'\\r\\n'.For example:RSA_PRIVATE_KEY=$(awk '{printf \"%s\\\\r\\\\n\", $0}' ssh_host_rsa_key)Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 162
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.public.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 163,
      "display_name": "tls.public.key",
      "documentation": "Public key that will be used to decrypt the data encrypted with the private\nkey.Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 163
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.passphrase",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 164,
      "display_name": "tls.passphrase",
      "documentation": "Passphrase that will be used to decrypt the private key if the given private\nkey is encrypted.Type: passwordDefault: [hidden]Importance: lowImportantThe SFTP Sink connector will fail iftls.passphraseis empty.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 164
      },
      "default": "[hidden]importance: lowimportantthe sftp sink connector will fail iftls.passphraseis empty."
    },
    {
      "name": "tls.pemfile",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 165,
      "display_name": "tls.pemfile",
      "documentation": "Path to pemfile.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 165
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "storage.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 166,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 166
      }
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 167,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Kafka.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 167
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 168,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 168
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 169,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 169
      },
      "default": "/importance: medium"
    },
    {
      "name": "file.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 170,
      "display_name": "file.delim",
      "documentation": "File delimiter patternType: stringDefault: +Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 170
      },
      "default": "+importance: medium"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 171,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. You can useDefaultPartitioner, which preserves the Kafka partitions;FieldPartitioner, which partitions the data to different directories according to the value of the partitioning field specified inpartition.field.name;TimeBasedPartitioner, which partitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 171
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 172,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field when FieldPartitioner is used.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 172
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 173,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 173
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 174,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 174
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 175,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 175
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 176,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 176
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 177,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 177
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 178,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 178
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "confluent.topic.bootstrap.servers",
      "type": "LISTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 179,
      "display_name": "confluent.topic.bootstrap.servers",
      "documentation": "A list of host/port pairs to use for establishing the initial connection to the Kafka cluster used for licensing. All servers in the cluster will be discovered from the initial connection. This list should be in the form <code>host1:port1,host2:port2,\u00e2\u0080\u00a6</code>. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).Type: listImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 179
      }
    },
    {
      "name": "confluent.topic",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 180,
      "display_name": "confluent.topic",
      "documentation": "Name of the Kafka topic used for Confluent Platform configuration, including licensing information.Type: stringDefault: _confluent-commandImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 180
      },
      "default": "_confluent-commandimportance: low"
    },
    {
      "name": "confluent.topic.replication.factor",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 181,
      "display_name": "confluent.topic.replication.factor",
      "documentation": "The replication factor for the Kafka topic used for Confluent Platform configuration, including licensing information. This is used only if the topic does not already exist, and the default of 3 is appropriate for production use. If you are using a development environment with less than 3 brokers, you must set this to the number of brokers (often 1).Type: intDefault: 3Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 181
      },
      "default": "3importance: low"
    },
    {
      "name": "confluent.license",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 182,
      "display_name": "confluent.license",
      "documentation": "Confluent issues enterprise license keys to each subscriber. The license key is text that you can copy and\npaste as the value forconfluent.license. A trial license allows using the connector for a 30-day trial period. A developer license allows using the connector indefinitely for single-broker development environments.If you are a subscriber, contact Confluent Support for more information.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Confluent Platform licenseImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 182
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: confluent platform licenseimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 183,
      "display_name": "confluent.topic.ssl.truststore.location",
      "documentation": "The location of the trust store file.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 183
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 184,
      "display_name": "confluent.topic.ssl.truststore.password",
      "documentation": "The password for the trust store file. If a password is not set access to the truststore is still available, but\nintegrity checking is disabled.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 184
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 185,
      "display_name": "confluent.topic.ssl.keystore.location",
      "documentation": "The location of the key store file. This is optional for client and can be used for two-way authentication for client.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 185
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 186,
      "display_name": "confluent.topic.ssl.keystore.password",
      "documentation": "The store password for the key store file. This is optional for client and only needed if ssl.keystore.location is configured.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 186
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.key.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 187,
      "display_name": "confluent.topic.ssl.key.password",
      "documentation": "The password of the private key in the key store file. This is optional for client.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 187
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.security.protocol",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 188,
      "display_name": "confluent.topic.security.protocol",
      "documentation": "Protocol used to communicate with brokers. Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.Type: stringDefault: \u00e2\u0080\u009cPLAINTEXT\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 188
      },
      "default": "\u00e2\u0080\u009cplaintext\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "format.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 189,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 189
      }
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 190,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 190
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 191,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. You can configure\nthis parameter so that the time interval is determined by using a timestamp\nextractor (for example, Kafka Record Time, Record Field, or Wall Clock\nextractor). When the first record is processed, a timestamp is set as the base\ntime. This is useful if you require exactly-once-semantics. This configuration\nensures that file commits are invoked at every configured interval. The\ndefault value-1indicates that this \u00e2\u0080\u009d feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 191
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 192,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This\nconfiguration ensures that file commits are invoked at every configured\ninterval. Time of commit will be adjusted to 00:00 the selected timezone. The\ncommit will be performed at the scheduled time, regardless of the previous\ncommit time or number of messages. This configuration is useful when you\nhave to commit your data based on current server time, for example at the\nbeginning of every hour. The default value-1means that this feature is\ndisabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 192
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schema.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 193,
      "display_name": "schema.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 193
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 194,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: falseImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 194
      },
      "default": "falseimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 195,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 195
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 196,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Kafka connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 196
      },
      "default": "5000importance: low"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 197,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 197
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 198,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output  files. Available values: null, deflate, snappy and bzip2 (CodecSource is org.apache.avro.file.CodecFactory)Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 198
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 199,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 199
      },
      "default": "noneimportance: high"
    },
    {
      "name": "sftp.host",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 200,
      "display_name": "sftp.host",
      "documentation": "Sftp host to connect withType: stringDefault: 127.0.0.1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 200
      },
      "default": "127.0.0.1importance: high"
    },
    {
      "name": "sftp.port",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 201,
      "display_name": "sftp.port",
      "documentation": "Port number of SFTP serverType: intDefault: 22Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 201
      },
      "default": "22importance: medium"
    },
    {
      "name": "sftp.username",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 202,
      "display_name": "sftp.username",
      "documentation": "Username for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 202
      }
    },
    {
      "name": "sftp.password",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 203,
      "display_name": "sftp.password",
      "documentation": "Password for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 203
      }
    },
    {
      "name": "sftp.proxy.url",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 204,
      "display_name": "sftp.proxy.url",
      "documentation": "Proxy url for sftp connection.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 204
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "proxy.username",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 205,
      "display_name": "proxy.username",
      "documentation": "Proxy username for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 205
      },
      "default": "nullimportance: low"
    },
    {
      "name": "proxy.password",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 206,
      "display_name": "proxy.password",
      "documentation": "Proxy password for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 206
      },
      "default": "nullimportance: low"
    },
    {
      "name": "sftp.compression.type",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 207,
      "display_name": "sftp.compression.type",
      "documentation": "Compression type for file written to sftp. Applied when using JsonFormat or ByteArrayFormat. Available values: none, gzip.Type: stringDefault: noneImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 207
      },
      "default": "noneimportance: low"
    },
    {
      "name": "sftp.working.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 208,
      "display_name": "sftp.working.dir",
      "documentation": "Home directory on SFTP server.This will be the top most directory that will contain all the filesType: stringDefault: /homeImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 208
      },
      "default": "/homeimportance: high"
    },
    {
      "name": "tls.private.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 209,
      "display_name": "tls.private.key",
      "documentation": "Private key that will be used for public-key authentication. When\nauthenticating with SSL:Use a non-empty passphrase.Replace private key newlines with'\\r\\n'.For example:RSA_PRIVATE_KEY=$(awk '{printf \"%s\\\\r\\\\n\", $0}' ssh_host_rsa_key)Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 209
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.public.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 210,
      "display_name": "tls.public.key",
      "documentation": "Public key that will be used to decrypt the data encrypted with the private\nkey.Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 210
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.passphrase",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 211,
      "display_name": "tls.passphrase",
      "documentation": "Passphrase that will be used to decrypt the private key if the given private\nkey is encrypted.Type: passwordDefault: [hidden]Importance: lowImportantThe SFTP Sink connector will fail iftls.passphraseis empty.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 211
      },
      "default": "[hidden]importance: lowimportantthe sftp sink connector will fail iftls.passphraseis empty."
    },
    {
      "name": "tls.pemfile",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 212,
      "display_name": "tls.pemfile",
      "documentation": "Path to pemfile.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 212
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "storage.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 213,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 213
      }
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 214,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Kafka.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 214
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 215,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 215
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 216,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 216
      },
      "default": "/importance: medium"
    },
    {
      "name": "file.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 217,
      "display_name": "file.delim",
      "documentation": "File delimiter patternType: stringDefault: +Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 217
      },
      "default": "+importance: medium"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 218,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. You can useDefaultPartitioner, which preserves the Kafka partitions;FieldPartitioner, which partitions the data to different directories according to the value of the partitioning field specified inpartition.field.name;TimeBasedPartitioner, which partitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 218
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 219,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field when FieldPartitioner is used.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 219
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 220,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 220
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 221,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 221
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 222,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 222
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 223,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 223
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 224,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 224
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 225,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 225
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "confluent.topic.bootstrap.servers",
      "type": "LISTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 226,
      "display_name": "confluent.topic.bootstrap.servers",
      "documentation": "A list of host/port pairs to use for establishing the initial connection to the Kafka cluster used for licensing. All servers in the cluster will be discovered from the initial connection. This list should be in the form <code>host1:port1,host2:port2,\u00e2\u0080\u00a6</code>. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).Type: listImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 226
      }
    },
    {
      "name": "confluent.topic",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 227,
      "display_name": "confluent.topic",
      "documentation": "Name of the Kafka topic used for Confluent Platform configuration, including licensing information.Type: stringDefault: _confluent-commandImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 227
      },
      "default": "_confluent-commandimportance: low"
    },
    {
      "name": "confluent.topic.replication.factor",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 228,
      "display_name": "confluent.topic.replication.factor",
      "documentation": "The replication factor for the Kafka topic used for Confluent Platform configuration, including licensing information. This is used only if the topic does not already exist, and the default of 3 is appropriate for production use. If you are using a development environment with less than 3 brokers, you must set this to the number of brokers (often 1).Type: intDefault: 3Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 228
      },
      "default": "3importance: low"
    },
    {
      "name": "confluent.license",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 229,
      "display_name": "confluent.license",
      "documentation": "Confluent issues enterprise license keys to each subscriber. The license key is text that you can copy and\npaste as the value forconfluent.license. A trial license allows using the connector for a 30-day trial period. A developer license allows using the connector indefinitely for single-broker development environments.If you are a subscriber, contact Confluent Support for more information.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Confluent Platform licenseImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 229
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: confluent platform licenseimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 230,
      "display_name": "confluent.topic.ssl.truststore.location",
      "documentation": "The location of the trust store file.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 230
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 231,
      "display_name": "confluent.topic.ssl.truststore.password",
      "documentation": "The password for the trust store file. If a password is not set access to the truststore is still available, but\nintegrity checking is disabled.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 231
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 232,
      "display_name": "confluent.topic.ssl.keystore.location",
      "documentation": "The location of the key store file. This is optional for client and can be used for two-way authentication for client.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 232
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 233,
      "display_name": "confluent.topic.ssl.keystore.password",
      "documentation": "The store password for the key store file. This is optional for client and only needed if ssl.keystore.location is configured.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 233
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.key.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 234,
      "display_name": "confluent.topic.ssl.key.password",
      "documentation": "The password of the private key in the key store file. This is optional for client.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 234
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.security.protocol",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 235,
      "display_name": "confluent.topic.security.protocol",
      "documentation": "Protocol used to communicate with brokers. Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.Type: stringDefault: \u00e2\u0080\u009cPLAINTEXT\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 235
      },
      "default": "\u00e2\u0080\u009cplaintext\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "format.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 236,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 236
      }
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 237,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 237
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 238,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. You can configure\nthis parameter so that the time interval is determined by using a timestamp\nextractor (for example, Kafka Record Time, Record Field, or Wall Clock\nextractor). When the first record is processed, a timestamp is set as the base\ntime. This is useful if you require exactly-once-semantics. This configuration\nensures that file commits are invoked at every configured interval. The\ndefault value-1indicates that this \u00e2\u0080\u009d feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 238
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 239,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This\nconfiguration ensures that file commits are invoked at every configured\ninterval. Time of commit will be adjusted to 00:00 the selected timezone. The\ncommit will be performed at the scheduled time, regardless of the previous\ncommit time or number of messages. This configuration is useful when you\nhave to commit your data based on current server time, for example at the\nbeginning of every hour. The default value-1means that this feature is\ndisabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 239
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schema.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 240,
      "display_name": "schema.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 240
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 241,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: falseImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 241
      },
      "default": "falseimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 242,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 242
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 243,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Kafka connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 243
      },
      "default": "5000importance: low"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 244,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 244
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 245,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output  files. Available values: null, deflate, snappy and bzip2 (CodecSource is org.apache.avro.file.CodecFactory)Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 245
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 246,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 246
      },
      "default": "noneimportance: high"
    },
    {
      "name": "sftp.host",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 247,
      "display_name": "sftp.host",
      "documentation": "Sftp host to connect withType: stringDefault: 127.0.0.1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 247
      },
      "default": "127.0.0.1importance: high"
    },
    {
      "name": "sftp.port",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 248,
      "display_name": "sftp.port",
      "documentation": "Port number of SFTP serverType: intDefault: 22Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 248
      },
      "default": "22importance: medium"
    },
    {
      "name": "sftp.username",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 249,
      "display_name": "sftp.username",
      "documentation": "Username for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 249
      }
    },
    {
      "name": "sftp.password",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 250,
      "display_name": "sftp.password",
      "documentation": "Password for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 250
      }
    },
    {
      "name": "sftp.proxy.url",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 251,
      "display_name": "sftp.proxy.url",
      "documentation": "Proxy url for sftp connection.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 251
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "proxy.username",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 252,
      "display_name": "proxy.username",
      "documentation": "Proxy username for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 252
      },
      "default": "nullimportance: low"
    },
    {
      "name": "proxy.password",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 253,
      "display_name": "proxy.password",
      "documentation": "Proxy password for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 253
      },
      "default": "nullimportance: low"
    },
    {
      "name": "sftp.compression.type",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 254,
      "display_name": "sftp.compression.type",
      "documentation": "Compression type for file written to sftp. Applied when using JsonFormat or ByteArrayFormat. Available values: none, gzip.Type: stringDefault: noneImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 254
      },
      "default": "noneimportance: low"
    },
    {
      "name": "sftp.working.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 255,
      "display_name": "sftp.working.dir",
      "documentation": "Home directory on SFTP server.This will be the top most directory that will contain all the filesType: stringDefault: /homeImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 255
      },
      "default": "/homeimportance: high"
    },
    {
      "name": "tls.private.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 256,
      "display_name": "tls.private.key",
      "documentation": "Private key that will be used for public-key authentication. When\nauthenticating with SSL:Use a non-empty passphrase.Replace private key newlines with'\\r\\n'.For example:RSA_PRIVATE_KEY=$(awk '{printf \"%s\\\\r\\\\n\", $0}' ssh_host_rsa_key)Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 256
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.public.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 257,
      "display_name": "tls.public.key",
      "documentation": "Public key that will be used to decrypt the data encrypted with the private\nkey.Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 257
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.passphrase",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 258,
      "display_name": "tls.passphrase",
      "documentation": "Passphrase that will be used to decrypt the private key if the given private\nkey is encrypted.Type: passwordDefault: [hidden]Importance: lowImportantThe SFTP Sink connector will fail iftls.passphraseis empty.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 258
      },
      "default": "[hidden]importance: lowimportantthe sftp sink connector will fail iftls.passphraseis empty."
    },
    {
      "name": "tls.pemfile",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 259,
      "display_name": "tls.pemfile",
      "documentation": "Path to pemfile.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 259
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "storage.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 260,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 260
      }
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 261,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Kafka.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 261
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 262,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 262
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 263,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 263
      },
      "default": "/importance: medium"
    },
    {
      "name": "file.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 264,
      "display_name": "file.delim",
      "documentation": "File delimiter patternType: stringDefault: +Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 264
      },
      "default": "+importance: medium"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 265,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. You can useDefaultPartitioner, which preserves the Kafka partitions;FieldPartitioner, which partitions the data to different directories according to the value of the partitioning field specified inpartition.field.name;TimeBasedPartitioner, which partitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 265
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 266,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field when FieldPartitioner is used.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 266
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 267,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 267
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 268,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 268
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 269,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 269
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 270,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 270
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 271,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 271
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 272,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 272
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "confluent.topic.bootstrap.servers",
      "type": "LISTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 273,
      "display_name": "confluent.topic.bootstrap.servers",
      "documentation": "A list of host/port pairs to use for establishing the initial connection to the Kafka cluster used for licensing. All servers in the cluster will be discovered from the initial connection. This list should be in the form <code>host1:port1,host2:port2,\u00e2\u0080\u00a6</code>. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).Type: listImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 273
      }
    },
    {
      "name": "confluent.topic",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 274,
      "display_name": "confluent.topic",
      "documentation": "Name of the Kafka topic used for Confluent Platform configuration, including licensing information.Type: stringDefault: _confluent-commandImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 274
      },
      "default": "_confluent-commandimportance: low"
    },
    {
      "name": "confluent.topic.replication.factor",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 275,
      "display_name": "confluent.topic.replication.factor",
      "documentation": "The replication factor for the Kafka topic used for Confluent Platform configuration, including licensing information. This is used only if the topic does not already exist, and the default of 3 is appropriate for production use. If you are using a development environment with less than 3 brokers, you must set this to the number of brokers (often 1).Type: intDefault: 3Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 275
      },
      "default": "3importance: low"
    },
    {
      "name": "confluent.license",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 276,
      "display_name": "confluent.license",
      "documentation": "Confluent issues enterprise license keys to each subscriber. The license key is text that you can copy and\npaste as the value forconfluent.license. A trial license allows using the connector for a 30-day trial period. A developer license allows using the connector indefinitely for single-broker development environments.If you are a subscriber, contact Confluent Support for more information.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Confluent Platform licenseImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 276
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: confluent platform licenseimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 277,
      "display_name": "confluent.topic.ssl.truststore.location",
      "documentation": "The location of the trust store file.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 277
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 278,
      "display_name": "confluent.topic.ssl.truststore.password",
      "documentation": "The password for the trust store file. If a password is not set access to the truststore is still available, but\nintegrity checking is disabled.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 278
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 279,
      "display_name": "confluent.topic.ssl.keystore.location",
      "documentation": "The location of the key store file. This is optional for client and can be used for two-way authentication for client.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 279
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 280,
      "display_name": "confluent.topic.ssl.keystore.password",
      "documentation": "The store password for the key store file. This is optional for client and only needed if ssl.keystore.location is configured.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 280
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.key.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 281,
      "display_name": "confluent.topic.ssl.key.password",
      "documentation": "The password of the private key in the key store file. This is optional for client.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 281
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.security.protocol",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 282,
      "display_name": "confluent.topic.security.protocol",
      "documentation": "Protocol used to communicate with brokers. Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.Type: stringDefault: \u00e2\u0080\u009cPLAINTEXT\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 282
      },
      "default": "\u00e2\u0080\u009cplaintext\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "format.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 283,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 283
      }
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 284,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 284
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 285,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. You can configure\nthis parameter so that the time interval is determined by using a timestamp\nextractor (for example, Kafka Record Time, Record Field, or Wall Clock\nextractor). When the first record is processed, a timestamp is set as the base\ntime. This is useful if you require exactly-once-semantics. This configuration\nensures that file commits are invoked at every configured interval. The\ndefault value-1indicates that this \u00e2\u0080\u009d feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 285
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 286,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This\nconfiguration ensures that file commits are invoked at every configured\ninterval. Time of commit will be adjusted to 00:00 the selected timezone. The\ncommit will be performed at the scheduled time, regardless of the previous\ncommit time or number of messages. This configuration is useful when you\nhave to commit your data based on current server time, for example at the\nbeginning of every hour. The default value-1means that this feature is\ndisabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 286
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schema.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 287,
      "display_name": "schema.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 287
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 288,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: falseImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 288
      },
      "default": "falseimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 289,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 289
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 290,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Kafka connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 290
      },
      "default": "5000importance: low"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 291,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 291
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 292,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output  files. Available values: null, deflate, snappy and bzip2 (CodecSource is org.apache.avro.file.CodecFactory)Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 292
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 293,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 293
      },
      "default": "noneimportance: high"
    },
    {
      "name": "sftp.host",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 294,
      "display_name": "sftp.host",
      "documentation": "Sftp host to connect withType: stringDefault: 127.0.0.1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 294
      },
      "default": "127.0.0.1importance: high"
    },
    {
      "name": "sftp.port",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 295,
      "display_name": "sftp.port",
      "documentation": "Port number of SFTP serverType: intDefault: 22Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 295
      },
      "default": "22importance: medium"
    },
    {
      "name": "sftp.username",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 296,
      "display_name": "sftp.username",
      "documentation": "Username for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 296
      }
    },
    {
      "name": "sftp.password",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 297,
      "display_name": "sftp.password",
      "documentation": "Password for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 297
      }
    },
    {
      "name": "sftp.proxy.url",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 298,
      "display_name": "sftp.proxy.url",
      "documentation": "Proxy url for sftp connection.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 298
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "proxy.username",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 299,
      "display_name": "proxy.username",
      "documentation": "Proxy username for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 299
      },
      "default": "nullimportance: low"
    },
    {
      "name": "proxy.password",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 300,
      "display_name": "proxy.password",
      "documentation": "Proxy password for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 300
      },
      "default": "nullimportance: low"
    },
    {
      "name": "sftp.compression.type",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 301,
      "display_name": "sftp.compression.type",
      "documentation": "Compression type for file written to sftp. Applied when using JsonFormat or ByteArrayFormat. Available values: none, gzip.Type: stringDefault: noneImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 301
      },
      "default": "noneimportance: low"
    },
    {
      "name": "sftp.working.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 302,
      "display_name": "sftp.working.dir",
      "documentation": "Home directory on SFTP server.This will be the top most directory that will contain all the filesType: stringDefault: /homeImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 302
      },
      "default": "/homeimportance: high"
    },
    {
      "name": "tls.private.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 303,
      "display_name": "tls.private.key",
      "documentation": "Private key that will be used for public-key authentication. When\nauthenticating with SSL:Use a non-empty passphrase.Replace private key newlines with'\\r\\n'.For example:RSA_PRIVATE_KEY=$(awk '{printf \"%s\\\\r\\\\n\", $0}' ssh_host_rsa_key)Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 303
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.public.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 304,
      "display_name": "tls.public.key",
      "documentation": "Public key that will be used to decrypt the data encrypted with the private\nkey.Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 304
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.passphrase",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 305,
      "display_name": "tls.passphrase",
      "documentation": "Passphrase that will be used to decrypt the private key if the given private\nkey is encrypted.Type: passwordDefault: [hidden]Importance: lowImportantThe SFTP Sink connector will fail iftls.passphraseis empty.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 305
      },
      "default": "[hidden]importance: lowimportantthe sftp sink connector will fail iftls.passphraseis empty."
    },
    {
      "name": "tls.pemfile",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 306,
      "display_name": "tls.pemfile",
      "documentation": "Path to pemfile.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 306
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "storage.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 307,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 307
      }
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 308,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Kafka.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 308
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 309,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 309
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 310,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 310
      },
      "default": "/importance: medium"
    },
    {
      "name": "file.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 311,
      "display_name": "file.delim",
      "documentation": "File delimiter patternType: stringDefault: +Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 311
      },
      "default": "+importance: medium"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 312,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. You can useDefaultPartitioner, which preserves the Kafka partitions;FieldPartitioner, which partitions the data to different directories according to the value of the partitioning field specified inpartition.field.name;TimeBasedPartitioner, which partitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 312
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 313,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field when FieldPartitioner is used.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 313
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 314,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 314
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 315,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 315
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 316,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 316
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 317,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 317
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 318,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 318
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 319,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 319
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "confluent.topic.bootstrap.servers",
      "type": "LISTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 320,
      "display_name": "confluent.topic.bootstrap.servers",
      "documentation": "A list of host/port pairs to use for establishing the initial connection to the Kafka cluster used for licensing. All servers in the cluster will be discovered from the initial connection. This list should be in the form <code>host1:port1,host2:port2,\u00e2\u0080\u00a6</code>. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).Type: listImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 320
      }
    },
    {
      "name": "confluent.topic",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 321,
      "display_name": "confluent.topic",
      "documentation": "Name of the Kafka topic used for Confluent Platform configuration, including licensing information.Type: stringDefault: _confluent-commandImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 321
      },
      "default": "_confluent-commandimportance: low"
    },
    {
      "name": "confluent.topic.replication.factor",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 322,
      "display_name": "confluent.topic.replication.factor",
      "documentation": "The replication factor for the Kafka topic used for Confluent Platform configuration, including licensing information. This is used only if the topic does not already exist, and the default of 3 is appropriate for production use. If you are using a development environment with less than 3 brokers, you must set this to the number of brokers (often 1).Type: intDefault: 3Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 322
      },
      "default": "3importance: low"
    },
    {
      "name": "confluent.license",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 323,
      "display_name": "confluent.license",
      "documentation": "Confluent issues enterprise license keys to each subscriber. The license key is text that you can copy and\npaste as the value forconfluent.license. A trial license allows using the connector for a 30-day trial period. A developer license allows using the connector indefinitely for single-broker development environments.If you are a subscriber, contact Confluent Support for more information.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Confluent Platform licenseImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 323
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: confluent platform licenseimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 324,
      "display_name": "confluent.topic.ssl.truststore.location",
      "documentation": "The location of the trust store file.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 324
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 325,
      "display_name": "confluent.topic.ssl.truststore.password",
      "documentation": "The password for the trust store file. If a password is not set access to the truststore is still available, but\nintegrity checking is disabled.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 325
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 326,
      "display_name": "confluent.topic.ssl.keystore.location",
      "documentation": "The location of the key store file. This is optional for client and can be used for two-way authentication for client.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 326
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 327,
      "display_name": "confluent.topic.ssl.keystore.password",
      "documentation": "The store password for the key store file. This is optional for client and only needed if ssl.keystore.location is configured.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 327
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.key.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 328,
      "display_name": "confluent.topic.ssl.key.password",
      "documentation": "The password of the private key in the key store file. This is optional for client.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 328
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.security.protocol",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 329,
      "display_name": "confluent.topic.security.protocol",
      "documentation": "Protocol used to communicate with brokers. Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.Type: stringDefault: \u00e2\u0080\u009cPLAINTEXT\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 329
      },
      "default": "\u00e2\u0080\u009cplaintext\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "format.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 330,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 330
      }
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 331,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 331
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 332,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. You can configure\nthis parameter so that the time interval is determined by using a timestamp\nextractor (for example, Kafka Record Time, Record Field, or Wall Clock\nextractor). When the first record is processed, a timestamp is set as the base\ntime. This is useful if you require exactly-once-semantics. This configuration\nensures that file commits are invoked at every configured interval. The\ndefault value-1indicates that this \u00e2\u0080\u009d feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 332
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 333,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This\nconfiguration ensures that file commits are invoked at every configured\ninterval. Time of commit will be adjusted to 00:00 the selected timezone. The\ncommit will be performed at the scheduled time, regardless of the previous\ncommit time or number of messages. This configuration is useful when you\nhave to commit your data based on current server time, for example at the\nbeginning of every hour. The default value-1means that this feature is\ndisabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 333
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schema.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 334,
      "display_name": "schema.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 334
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 335,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: falseImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 335
      },
      "default": "falseimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 336,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 336
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 337,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Kafka connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 337
      },
      "default": "5000importance: low"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 338,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 338
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 339,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output  files. Available values: null, deflate, snappy and bzip2 (CodecSource is org.apache.avro.file.CodecFactory)Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 339
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 340,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 340
      },
      "default": "noneimportance: high"
    },
    {
      "name": "sftp.host",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 341,
      "display_name": "sftp.host",
      "documentation": "Sftp host to connect withType: stringDefault: 127.0.0.1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 341
      },
      "default": "127.0.0.1importance: high"
    },
    {
      "name": "sftp.port",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 342,
      "display_name": "sftp.port",
      "documentation": "Port number of SFTP serverType: intDefault: 22Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 342
      },
      "default": "22importance: medium"
    },
    {
      "name": "sftp.username",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 343,
      "display_name": "sftp.username",
      "documentation": "Username for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 343
      }
    },
    {
      "name": "sftp.password",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 344,
      "display_name": "sftp.password",
      "documentation": "Password for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 344
      }
    },
    {
      "name": "sftp.proxy.url",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 345,
      "display_name": "sftp.proxy.url",
      "documentation": "Proxy url for sftp connection.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 345
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "proxy.username",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 346,
      "display_name": "proxy.username",
      "documentation": "Proxy username for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 346
      },
      "default": "nullimportance: low"
    },
    {
      "name": "proxy.password",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 347,
      "display_name": "proxy.password",
      "documentation": "Proxy password for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 347
      },
      "default": "nullimportance: low"
    },
    {
      "name": "sftp.compression.type",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 348,
      "display_name": "sftp.compression.type",
      "documentation": "Compression type for file written to sftp. Applied when using JsonFormat or ByteArrayFormat. Available values: none, gzip.Type: stringDefault: noneImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 348
      },
      "default": "noneimportance: low"
    },
    {
      "name": "sftp.working.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 349,
      "display_name": "sftp.working.dir",
      "documentation": "Home directory on SFTP server.This will be the top most directory that will contain all the filesType: stringDefault: /homeImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 349
      },
      "default": "/homeimportance: high"
    },
    {
      "name": "tls.private.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 350,
      "display_name": "tls.private.key",
      "documentation": "Private key that will be used for public-key authentication. When\nauthenticating with SSL:Use a non-empty passphrase.Replace private key newlines with'\\r\\n'.For example:RSA_PRIVATE_KEY=$(awk '{printf \"%s\\\\r\\\\n\", $0}' ssh_host_rsa_key)Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 350
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.public.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 351,
      "display_name": "tls.public.key",
      "documentation": "Public key that will be used to decrypt the data encrypted with the private\nkey.Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 351
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.passphrase",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 352,
      "display_name": "tls.passphrase",
      "documentation": "Passphrase that will be used to decrypt the private key if the given private\nkey is encrypted.Type: passwordDefault: [hidden]Importance: lowImportantThe SFTP Sink connector will fail iftls.passphraseis empty.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 352
      },
      "default": "[hidden]importance: lowimportantthe sftp sink connector will fail iftls.passphraseis empty."
    },
    {
      "name": "tls.pemfile",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 353,
      "display_name": "tls.pemfile",
      "documentation": "Path to pemfile.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 353
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "storage.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 354,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 354
      }
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 355,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Kafka.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 355
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 356,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 356
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 357,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 357
      },
      "default": "/importance: medium"
    },
    {
      "name": "file.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 358,
      "display_name": "file.delim",
      "documentation": "File delimiter patternType: stringDefault: +Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 358
      },
      "default": "+importance: medium"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 359,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. You can useDefaultPartitioner, which preserves the Kafka partitions;FieldPartitioner, which partitions the data to different directories according to the value of the partitioning field specified inpartition.field.name;TimeBasedPartitioner, which partitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 359
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 360,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field when FieldPartitioner is used.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 360
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 361,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 361
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 362,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 362
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 363,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 363
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 364,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 364
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 365,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 365
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 366,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 366
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "confluent.topic.bootstrap.servers",
      "type": "LISTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 367,
      "display_name": "confluent.topic.bootstrap.servers",
      "documentation": "A list of host/port pairs to use for establishing the initial connection to the Kafka cluster used for licensing. All servers in the cluster will be discovered from the initial connection. This list should be in the form <code>host1:port1,host2:port2,\u00e2\u0080\u00a6</code>. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).Type: listImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 367
      }
    },
    {
      "name": "confluent.topic",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 368,
      "display_name": "confluent.topic",
      "documentation": "Name of the Kafka topic used for Confluent Platform configuration, including licensing information.Type: stringDefault: _confluent-commandImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 368
      },
      "default": "_confluent-commandimportance: low"
    },
    {
      "name": "confluent.topic.replication.factor",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 369,
      "display_name": "confluent.topic.replication.factor",
      "documentation": "The replication factor for the Kafka topic used for Confluent Platform configuration, including licensing information. This is used only if the topic does not already exist, and the default of 3 is appropriate for production use. If you are using a development environment with less than 3 brokers, you must set this to the number of brokers (often 1).Type: intDefault: 3Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 369
      },
      "default": "3importance: low"
    },
    {
      "name": "confluent.license",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 370,
      "display_name": "confluent.license",
      "documentation": "Confluent issues enterprise license keys to each subscriber. The license key is text that you can copy and\npaste as the value forconfluent.license. A trial license allows using the connector for a 30-day trial period. A developer license allows using the connector indefinitely for single-broker development environments.If you are a subscriber, contact Confluent Support for more information.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Confluent Platform licenseImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 370
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: confluent platform licenseimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 371,
      "display_name": "confluent.topic.ssl.truststore.location",
      "documentation": "The location of the trust store file.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 371
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 372,
      "display_name": "confluent.topic.ssl.truststore.password",
      "documentation": "The password for the trust store file. If a password is not set access to the truststore is still available, but\nintegrity checking is disabled.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 372
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 373,
      "display_name": "confluent.topic.ssl.keystore.location",
      "documentation": "The location of the key store file. This is optional for client and can be used for two-way authentication for client.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 373
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 374,
      "display_name": "confluent.topic.ssl.keystore.password",
      "documentation": "The store password for the key store file. This is optional for client and only needed if ssl.keystore.location is configured.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 374
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.key.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 375,
      "display_name": "confluent.topic.ssl.key.password",
      "documentation": "The password of the private key in the key store file. This is optional for client.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 375
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.security.protocol",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 376,
      "display_name": "confluent.topic.security.protocol",
      "documentation": "Protocol used to communicate with brokers. Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.Type: stringDefault: \u00e2\u0080\u009cPLAINTEXT\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 376
      },
      "default": "\u00e2\u0080\u009cplaintext\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "format.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 377,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 377
      }
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 378,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 378
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 379,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. You can configure\nthis parameter so that the time interval is determined by using a timestamp\nextractor (for example, Kafka Record Time, Record Field, or Wall Clock\nextractor). When the first record is processed, a timestamp is set as the base\ntime. This is useful if you require exactly-once-semantics. This configuration\nensures that file commits are invoked at every configured interval. The\ndefault value-1indicates that this \u00e2\u0080\u009d feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 379
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 380,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This\nconfiguration ensures that file commits are invoked at every configured\ninterval. Time of commit will be adjusted to 00:00 the selected timezone. The\ncommit will be performed at the scheduled time, regardless of the previous\ncommit time or number of messages. This configuration is useful when you\nhave to commit your data based on current server time, for example at the\nbeginning of every hour. The default value-1means that this feature is\ndisabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 380
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schema.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 381,
      "display_name": "schema.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 381
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 382,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: falseImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 382
      },
      "default": "falseimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 383,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 383
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 384,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Kafka connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 384
      },
      "default": "5000importance: low"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 385,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 385
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 386,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output  files. Available values: null, deflate, snappy and bzip2 (CodecSource is org.apache.avro.file.CodecFactory)Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 386
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 387,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 387
      },
      "default": "noneimportance: high"
    },
    {
      "name": "sftp.host",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 388,
      "display_name": "sftp.host",
      "documentation": "Sftp host to connect withType: stringDefault: 127.0.0.1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 388
      },
      "default": "127.0.0.1importance: high"
    },
    {
      "name": "sftp.port",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 389,
      "display_name": "sftp.port",
      "documentation": "Port number of SFTP serverType: intDefault: 22Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 389
      },
      "default": "22importance: medium"
    },
    {
      "name": "sftp.username",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 390,
      "display_name": "sftp.username",
      "documentation": "Username for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 390
      }
    },
    {
      "name": "sftp.password",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 391,
      "display_name": "sftp.password",
      "documentation": "Password for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 391
      }
    },
    {
      "name": "sftp.proxy.url",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 392,
      "display_name": "sftp.proxy.url",
      "documentation": "Proxy url for sftp connection.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 392
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "proxy.username",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 393,
      "display_name": "proxy.username",
      "documentation": "Proxy username for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 393
      },
      "default": "nullimportance: low"
    },
    {
      "name": "proxy.password",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 394,
      "display_name": "proxy.password",
      "documentation": "Proxy password for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 394
      },
      "default": "nullimportance: low"
    },
    {
      "name": "sftp.compression.type",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 395,
      "display_name": "sftp.compression.type",
      "documentation": "Compression type for file written to sftp. Applied when using JsonFormat or ByteArrayFormat. Available values: none, gzip.Type: stringDefault: noneImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 395
      },
      "default": "noneimportance: low"
    },
    {
      "name": "sftp.working.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 396,
      "display_name": "sftp.working.dir",
      "documentation": "Home directory on SFTP server.This will be the top most directory that will contain all the filesType: stringDefault: /homeImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 396
      },
      "default": "/homeimportance: high"
    },
    {
      "name": "tls.private.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 397,
      "display_name": "tls.private.key",
      "documentation": "Private key that will be used for public-key authentication. When\nauthenticating with SSL:Use a non-empty passphrase.Replace private key newlines with'\\r\\n'.For example:RSA_PRIVATE_KEY=$(awk '{printf \"%s\\\\r\\\\n\", $0}' ssh_host_rsa_key)Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 397
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.public.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 398,
      "display_name": "tls.public.key",
      "documentation": "Public key that will be used to decrypt the data encrypted with the private\nkey.Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 398
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.passphrase",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 399,
      "display_name": "tls.passphrase",
      "documentation": "Passphrase that will be used to decrypt the private key if the given private\nkey is encrypted.Type: passwordDefault: [hidden]Importance: lowImportantThe SFTP Sink connector will fail iftls.passphraseis empty.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 399
      },
      "default": "[hidden]importance: lowimportantthe sftp sink connector will fail iftls.passphraseis empty."
    },
    {
      "name": "tls.pemfile",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 400,
      "display_name": "tls.pemfile",
      "documentation": "Path to pemfile.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 400
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "storage.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 401,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 401
      }
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 402,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Kafka.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 402
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 403,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 403
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 404,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 404
      },
      "default": "/importance: medium"
    },
    {
      "name": "file.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 405,
      "display_name": "file.delim",
      "documentation": "File delimiter patternType: stringDefault: +Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 405
      },
      "default": "+importance: medium"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 406,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. You can useDefaultPartitioner, which preserves the Kafka partitions;FieldPartitioner, which partitions the data to different directories according to the value of the partitioning field specified inpartition.field.name;TimeBasedPartitioner, which partitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 406
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 407,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field when FieldPartitioner is used.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 407
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 408,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 408
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 409,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 409
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 410,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 410
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 411,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 411
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 412,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 412
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 413,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 413
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "confluent.topic.bootstrap.servers",
      "type": "LISTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 414,
      "display_name": "confluent.topic.bootstrap.servers",
      "documentation": "A list of host/port pairs to use for establishing the initial connection to the Kafka cluster used for licensing. All servers in the cluster will be discovered from the initial connection. This list should be in the form <code>host1:port1,host2:port2,\u00e2\u0080\u00a6</code>. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).Type: listImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 414
      }
    },
    {
      "name": "confluent.topic",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 415,
      "display_name": "confluent.topic",
      "documentation": "Name of the Kafka topic used for Confluent Platform configuration, including licensing information.Type: stringDefault: _confluent-commandImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 415
      },
      "default": "_confluent-commandimportance: low"
    },
    {
      "name": "confluent.topic.replication.factor",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 416,
      "display_name": "confluent.topic.replication.factor",
      "documentation": "The replication factor for the Kafka topic used for Confluent Platform configuration, including licensing information. This is used only if the topic does not already exist, and the default of 3 is appropriate for production use. If you are using a development environment with less than 3 brokers, you must set this to the number of brokers (often 1).Type: intDefault: 3Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 416
      },
      "default": "3importance: low"
    },
    {
      "name": "confluent.license",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 417,
      "display_name": "confluent.license",
      "documentation": "Confluent issues enterprise license keys to each subscriber. The license key is text that you can copy and\npaste as the value forconfluent.license. A trial license allows using the connector for a 30-day trial period. A developer license allows using the connector indefinitely for single-broker development environments.If you are a subscriber, contact Confluent Support for more information.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Confluent Platform licenseImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 417
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: confluent platform licenseimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 418,
      "display_name": "confluent.topic.ssl.truststore.location",
      "documentation": "The location of the trust store file.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 418
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 419,
      "display_name": "confluent.topic.ssl.truststore.password",
      "documentation": "The password for the trust store file. If a password is not set access to the truststore is still available, but\nintegrity checking is disabled.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 419
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 420,
      "display_name": "confluent.topic.ssl.keystore.location",
      "documentation": "The location of the key store file. This is optional for client and can be used for two-way authentication for client.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 420
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 421,
      "display_name": "confluent.topic.ssl.keystore.password",
      "documentation": "The store password for the key store file. This is optional for client and only needed if ssl.keystore.location is configured.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 421
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.key.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 422,
      "display_name": "confluent.topic.ssl.key.password",
      "documentation": "The password of the private key in the key store file. This is optional for client.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 422
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.security.protocol",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 423,
      "display_name": "confluent.topic.security.protocol",
      "documentation": "Protocol used to communicate with brokers. Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.Type: stringDefault: \u00e2\u0080\u009cPLAINTEXT\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 423
      },
      "default": "\u00e2\u0080\u009cplaintext\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "format.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 424,
      "display_name": "format.class",
      "documentation": "The format class to use when writing data to the store.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 424
      }
    },
    {
      "name": "flush.size",
      "type": "INTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 425,
      "display_name": "flush.size",
      "documentation": "Number of records written to store before invoking file commits.Type: intImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 425
      }
    },
    {
      "name": "rotate.interval.ms",
      "type": "LONGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Connector",
      "order_in_group": 426,
      "display_name": "rotate.interval.ms",
      "documentation": "The time interval in milliseconds to invoke file commits. You can configure\nthis parameter so that the time interval is determined by using a timestamp\nextractor (for example, Kafka Record Time, Record Field, or Wall Clock\nextractor). When the first record is processed, a timestamp is set as the base\ntime. This is useful if you require exactly-once-semantics. This configuration\nensures that file commits are invoked at every configured interval. The\ndefault value-1indicates that this \u00e2\u0080\u009d feature is disabled.Type: longDefault: -1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 426
      },
      "default": "-1importance: high"
    },
    {
      "name": "rotate.schedule.interval.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Connector",
      "order_in_group": 427,
      "display_name": "rotate.schedule.interval.ms",
      "documentation": "The time interval in milliseconds to periodically invoke file commits. This\nconfiguration ensures that file commits are invoked at every configured\ninterval. Time of commit will be adjusted to 00:00 the selected timezone. The\ncommit will be performed at the scheduled time, regardless of the previous\ncommit time or number of messages. This configuration is useful when you\nhave to commit your data based on current server time, for example at the\nbeginning of every hour. The default value-1means that this feature is\ndisabled.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 427
      },
      "default": "-1importance: medium"
    },
    {
      "name": "schema.cache.config",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 428,
      "display_name": "schema.cache.config",
      "documentation": "The size of the schema cache used in the Avro converter.Type: intDefault: 1000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 428
      },
      "default": "1000importance: low"
    },
    {
      "name": "enhanced.avro.schema.support",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 429,
      "display_name": "enhanced.avro.schema.support",
      "documentation": "Enable enhanced Avro schema support in the Avro Converter. When set totrue, this property preserves Avro schema package information and Enums when going from Avro schema to Connect schema. This information is added back in when going from Connect schema to Avro schema.Type: booleanDefault: falseImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 429
      },
      "default": "falseimportance: low"
    },
    {
      "name": "connect.meta.data",
      "type": "BOOLEANDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 430,
      "display_name": "connect.meta.data",
      "documentation": "Allow the Connect converter to add its metadata to the output schema.Type: booleanDefault: trueImportance: lowTheconnect.meta.dataproperty preserves the following Connect schema metadata when going from Connect schema to Avro schema. The following metadata is added back in when going from Avro schema to Connect schema.docversionparametersdefault valuenametype",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 430
      },
      "default": "trueimportance: lowtheconnect.meta.dataproperty preserves the following connect schema metadata when going from connect schema to avro schema. the following metadata is added back in when going from avro schema to connect schema.docversionparametersdefault valuenametype"
    },
    {
      "name": "retry.backoff.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 431,
      "display_name": "retry.backoff.ms",
      "documentation": "The retry backoff in milliseconds. This config is used to notify Kafka connect to retry delivering a message batch or performing recovery in case of transient exceptions.Type: longDefault: 5000Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 431
      },
      "default": "5000importance: low"
    },
    {
      "name": "filename.offset.zero.pad.width",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 432,
      "display_name": "filename.offset.zero.pad.width",
      "documentation": "Width to zero-pad offsets in store\u00e2\u0080\u0099s filenames if offsets are too short in order to provide fixed-width filenames that can be ordered by simple lexicographic sorting.Type: intDefault: 10Valid Values: [0,\u00e2\u0080\u00a6]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 432
      },
      "default": "10valid values: [0,\u00e2\u0080\u00a6]importance: low",
      "valid_values": [
        "0",
        "\u00e2\u0080\u00a6"
      ]
    },
    {
      "name": "avro.codec",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Connector",
      "order_in_group": 433,
      "display_name": "avro.codec",
      "documentation": "The Avro compression codec to be used for output  files. Available values: null, deflate, snappy and bzip2 (CodecSource is org.apache.avro.file.CodecFactory)Type: stringDefault: nullValid Values: [null, deflate, snappy, bzip2]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 433
      },
      "default": "nullvalid values: [null, deflate, snappy, bzip2]importance: low",
      "valid_values": [
        "null",
        "deflate",
        "snappy",
        "bzip2"
      ]
    },
    {
      "name": "schema.compatibility",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Schema",
      "order_in_group": 434,
      "display_name": "schema.compatibility",
      "documentation": "The schema compatibility rule to use when the connector is observing schema changes. The supported configurations are NONE, BACKWARD, FORWARD and FULL.Type: stringDefault: NONEImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 434
      },
      "default": "noneimportance: high"
    },
    {
      "name": "sftp.host",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "SFTP",
      "order_in_group": 435,
      "display_name": "sftp.host",
      "documentation": "Sftp host to connect withType: stringDefault: 127.0.0.1Importance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 435
      },
      "default": "127.0.0.1importance: high"
    },
    {
      "name": "sftp.port",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "SFTP",
      "order_in_group": 436,
      "display_name": "sftp.port",
      "documentation": "Port number of SFTP serverType: intDefault: 22Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 436
      },
      "default": "22importance: medium"
    },
    {
      "name": "sftp.username",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "SFTP",
      "order_in_group": 437,
      "display_name": "sftp.username",
      "documentation": "Username for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 437
      }
    },
    {
      "name": "sftp.password",
      "type": "STRINGIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "SFTP",
      "order_in_group": 438,
      "display_name": "sftp.password",
      "documentation": "Password for sftp serverType: stringImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 438
      }
    },
    {
      "name": "sftp.proxy.url",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "SFTP",
      "order_in_group": 439,
      "display_name": "sftp.proxy.url",
      "documentation": "Proxy url for sftp connection.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 439
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "proxy.username",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "SFTP",
      "order_in_group": 440,
      "display_name": "proxy.username",
      "documentation": "Proxy username for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 440
      },
      "default": "nullimportance: low"
    },
    {
      "name": "proxy.password",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "SFTP",
      "order_in_group": 441,
      "display_name": "proxy.password",
      "documentation": "Proxy password for sftp server if proxy is to usedType: stringDefault: nullImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 441
      },
      "default": "nullimportance: low"
    },
    {
      "name": "sftp.compression.type",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "SFTP",
      "order_in_group": 442,
      "display_name": "sftp.compression.type",
      "documentation": "Compression type for file written to sftp. Applied when using JsonFormat or ByteArrayFormat. Available values: none, gzip.Type: stringDefault: noneImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 442
      },
      "default": "noneimportance: low"
    },
    {
      "name": "sftp.working.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "SFTP",
      "order_in_group": 443,
      "display_name": "sftp.working.dir",
      "documentation": "Home directory on SFTP server.This will be the top most directory that will contain all the filesType: stringDefault: /homeImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 443
      },
      "default": "/homeimportance: high"
    },
    {
      "name": "tls.private.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Security",
      "order_in_group": 444,
      "display_name": "tls.private.key",
      "documentation": "Private key that will be used for public-key authentication. When\nauthenticating with SSL:Use a non-empty passphrase.Replace private key newlines with'\\r\\n'.For example:RSA_PRIVATE_KEY=$(awk '{printf \"%s\\\\r\\\\n\", $0}' ssh_host_rsa_key)Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 444
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.public.key",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Security",
      "order_in_group": 445,
      "display_name": "tls.public.key",
      "documentation": "Public key that will be used to decrypt the data encrypted with the private\nkey.Type: passwordDefault: [hidden]Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 445
      },
      "default": "[hidden]importance: low"
    },
    {
      "name": "tls.passphrase",
      "type": "PASSWORDDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Security",
      "order_in_group": 446,
      "display_name": "tls.passphrase",
      "documentation": "Passphrase that will be used to decrypt the private key if the given private\nkey is encrypted.Type: passwordDefault: [hidden]Importance: lowImportantThe SFTP Sink connector will fail iftls.passphraseis empty.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 446
      },
      "default": "[hidden]importance: lowimportantthe sftp sink connector will fail iftls.passphraseis empty."
    },
    {
      "name": "tls.pemfile",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Security",
      "order_in_group": 447,
      "display_name": "tls.pemfile",
      "documentation": "Path to pemfile.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 447
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: low"
    },
    {
      "name": "storage.class",
      "type": "CLASSIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Storage",
      "order_in_group": 448,
      "display_name": "storage.class",
      "documentation": "The underlying storage layer.Type: classImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 448
      }
    },
    {
      "name": "topics.dir",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Storage",
      "order_in_group": 449,
      "display_name": "topics.dir",
      "documentation": "Top level directory to store the data ingested from Kafka.Type: stringDefault: topicsImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 449
      },
      "default": "topicsimportance: high"
    },
    {
      "name": "store.url",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Storage",
      "order_in_group": 450,
      "display_name": "store.url",
      "documentation": "Store\u00e2\u0080\u0099s connection URL, if applicable.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 450
      },
      "default": "nullimportance: high"
    },
    {
      "name": "directory.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Storage",
      "order_in_group": 451,
      "display_name": "directory.delim",
      "documentation": "Directory delimiter patternType: stringDefault: /Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 451
      },
      "default": "/importance: medium"
    },
    {
      "name": "file.delim",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Storage",
      "order_in_group": 452,
      "display_name": "file.delim",
      "documentation": "File delimiter patternType: stringDefault: +Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 452
      },
      "default": "+importance: medium"
    },
    {
      "name": "partitioner.class",
      "type": "CLASSDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Partitioner",
      "order_in_group": 453,
      "display_name": "partitioner.class",
      "documentation": "The partitioner to use when writing data to the store. You can useDefaultPartitioner, which preserves the Kafka partitions;FieldPartitioner, which partitions the data to different directories according to the value of the partitioning field specified inpartition.field.name;TimeBasedPartitioner, which partitions data according to ingestion time.Type: classDefault: io.confluent.connect.storage.partitioner.DefaultPartitionerImportance: highDependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 453
      },
      "default": "io.confluent.connect.storage.partitioner.defaultpartitionerimportance: highdependents:partition.field.name,partition.duration.ms,path.format,locale,timezone",
      "dependents": [
        "partition.field.name",
        "partition.duration.ms",
        "path.format",
        "locale",
        "timezone"
      ]
    },
    {
      "name": "partition.field.name",
      "type": "LISTDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 454,
      "display_name": "partition.field.name",
      "documentation": "The name of the partitioning field when FieldPartitioner is used.Type: listDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 454
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "partition.duration.ms",
      "type": "LONGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 455,
      "display_name": "partition.duration.ms",
      "documentation": "The duration of a partition milliseconds used byTimeBasedPartitioner. The default value -1 means that we are not usingTimeBasedPartitioner.Type: longDefault: -1Importance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 455
      },
      "default": "-1importance: medium"
    },
    {
      "name": "path.format",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 456,
      "display_name": "path.format",
      "documentation": "This configuration is used to set the format of the data directories when partitioning withTimeBasedPartitioner. The format set in this configuration converts the Unix timestamp to proper directories strings. For example, if you setpath.format='year'=YYYY/'month'=MM/'day'=dd/'hour'=HH, the data directories will have the format/year=2015/month=12/day=07/hour=15/.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 456
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "locale",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 457,
      "display_name": "locale",
      "documentation": "The locale to use when partitioning withTimeBasedPartitioner. Used to format dates and times. For example, useen-USfor US English,en-GBfor UK English, orfr-FRfor French (in France). These may vary by Java version. See theavailable locales.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 457
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timezone",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 458,
      "display_name": "timezone",
      "documentation": "The timezone to use when partitioning withTimeBasedPartitioner. Used to format and compute dates and times. All timezone IDs must be specified in the long format, such asAmerica/Los_Angeles,America/New_York, andEurope/Paris, orUTC. Alternatively a locale independent, fixed offset, datetime zone can be specified in form[+-]hh:mm. Support for these timezones may vary by Java version. See theavailable timezones within each locale, such asthose within the US English locale.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 458
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "timestamp.extractor",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 459,
      "display_name": "timestamp.extractor",
      "documentation": "The extractor that gets the timestamp for records when partitioning withTimeBasedPartitioner. It can be set toWallclock,RecordorRecordFieldin order to use one of the built-in timestamp extractors or be given the fully-qualified class name of a user-defined class that extends theTimestampExtractorinterface.Type: stringDefault: WallclockImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 459
      },
      "default": "wallclockimportance: medium"
    },
    {
      "name": "timestamp.field",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Partitioner",
      "order_in_group": 460,
      "display_name": "timestamp.field",
      "documentation": "The record field to be used as timestamp by the timestamp extractor.Type: stringDefault: timestampImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 460
      },
      "default": "timestampimportance: medium"
    },
    {
      "name": "confluent.topic.bootstrap.servers",
      "type": "LISTIMPORTANCE",
      "required": true,
      "importance": "HIGH",
      "group": "Confluent Platform license",
      "order_in_group": 461,
      "display_name": "confluent.topic.bootstrap.servers",
      "documentation": "A list of host/port pairs to use for establishing the initial connection to the Kafka cluster used for licensing. All servers in the cluster will be discovered from the initial connection. This list should be in the form <code>host1:port1,host2:port2,\u00e2\u0080\u00a6</code>. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).Type: listImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 461
      }
    },
    {
      "name": "confluent.topic",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Confluent Platform license",
      "order_in_group": 462,
      "display_name": "confluent.topic",
      "documentation": "Name of the Kafka topic used for Confluent Platform configuration, including licensing information.Type: stringDefault: _confluent-commandImportance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 462
      },
      "default": "_confluent-commandimportance: low"
    },
    {
      "name": "confluent.topic.replication.factor",
      "type": "INTDEFAULT",
      "required": false,
      "importance": "LOW",
      "group": "Confluent Platform license",
      "order_in_group": 463,
      "display_name": "confluent.topic.replication.factor",
      "documentation": "The replication factor for the Kafka topic used for Confluent Platform configuration, including licensing information. This is used only if the topic does not already exist, and the default of 3 is appropriate for production use. If you are using a development environment with less than 3 brokers, you must set this to the number of brokers (often 1).Type: intDefault: 3Importance: low",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 463
      },
      "default": "3importance: low"
    },
    {
      "name": "confluent.license",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Confluent Platform license",
      "order_in_group": 464,
      "display_name": "confluent.license",
      "documentation": "Confluent issues enterprise license keys to each subscriber. The license key is text that you can copy and\npaste as the value forconfluent.license. A trial license allows using the connector for a 30-day trial period. A developer license allows using the connector indefinitely for single-broker development environments.If you are a subscriber, contact Confluent Support for more information.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Confluent Platform licenseImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 464
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: confluent platform licenseimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Confluent Platform license",
      "order_in_group": 465,
      "display_name": "confluent.topic.ssl.truststore.location",
      "documentation": "The location of the trust store file.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 465
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Confluent Platform license",
      "order_in_group": 466,
      "display_name": "confluent.topic.ssl.truststore.password",
      "documentation": "The password for the trust store file. If a password is not set access to the truststore is still available, but\nintegrity checking is disabled.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 466
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Confluent Platform license",
      "order_in_group": 467,
      "display_name": "confluent.topic.ssl.keystore.location",
      "documentation": "The location of the key store file. This is optional for client and can be used for two-way authentication for client.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 467
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Confluent Platform license",
      "order_in_group": 468,
      "display_name": "confluent.topic.ssl.keystore.password",
      "documentation": "The store password for the key store file. This is optional for client and only needed if ssl.keystore.location is configured.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 468
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.key.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Confluent Platform license",
      "order_in_group": 469,
      "display_name": "confluent.topic.ssl.key.password",
      "documentation": "The password of the private key in the key store file. This is optional for client.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 469
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.security.protocol",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Confluent Platform license",
      "order_in_group": 470,
      "display_name": "confluent.topic.security.protocol",
      "documentation": "Protocol used to communicate with brokers. Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.Type: stringDefault: \u00e2\u0080\u009cPLAINTEXT\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 470
      },
      "default": "\u00e2\u0080\u009cplaintext\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "confluent.license",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Confluent license properties",
      "order_in_group": 471,
      "display_name": "confluent.license",
      "documentation": "Confluent issues enterprise license keys to each subscriber. The license key is text that you can copy and\npaste as the value forconfluent.license. A trial license allows using the connector for a 30-day trial period. A developer license allows using the connector indefinitely for single-broker development environments.If you are a subscriber, contact Confluent Support for more information.Type: stringDefault: \u00e2\u0080\u009c\u00e2\u0080\u009dValid Values: Confluent Platform licenseImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 471
      },
      "default": "\u00e2\u0080\u009c\u00e2\u0080\u009dvalid values: confluent platform licenseimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Confluent license properties",
      "order_in_group": 472,
      "display_name": "confluent.topic.ssl.truststore.location",
      "documentation": "The location of the trust store file.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 472
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.truststore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Confluent license properties",
      "order_in_group": 473,
      "display_name": "confluent.topic.ssl.truststore.password",
      "documentation": "The password for the trust store file. If a password is not set access to the truststore is still available, but\nintegrity checking is disabled.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 473
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.location",
      "type": "STRINGDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Confluent license properties",
      "order_in_group": 474,
      "display_name": "confluent.topic.ssl.keystore.location",
      "documentation": "The location of the key store file. This is optional for client and can be used for two-way authentication for client.Type: stringDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 474
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.keystore.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Confluent license properties",
      "order_in_group": 475,
      "display_name": "confluent.topic.ssl.keystore.password",
      "documentation": "The store password for the key store file. This is optional for client and only needed if ssl.keystore.location is configured.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 475
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.ssl.key.password",
      "type": "PASSWORDDEFAULT",
      "required": true,
      "importance": "HIGH",
      "group": "Confluent license properties",
      "order_in_group": 476,
      "display_name": "confluent.topic.ssl.key.password",
      "documentation": "The password of the private key in the key store file. This is optional for client.Type: passwordDefault: nullImportance: high",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 476
      },
      "default": "nullimportance: high"
    },
    {
      "name": "confluent.topic.security.protocol",
      "type": "STRINGDEFAULT",
      "required": false,
      "importance": "MEDIUM",
      "group": "Confluent license properties",
      "order_in_group": 477,
      "display_name": "confluent.topic.security.protocol",
      "documentation": "Protocol used to communicate with brokers. Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.Type: stringDefault: \u00e2\u0080\u009cPLAINTEXT\u00e2\u0080\u009dImportance: medium",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 477
      },
      "default": "\u00e2\u0080\u009cplaintext\u00e2\u0080\u009dimportance: medium"
    },
    {
      "name": "Search by configuration property name",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 2,
      "display_name": "Search by configuration property name",
      "documentation": "Enter a string to search and filter by configuration property name.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 2
      }
    },
    {
      "name": "name",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 2,
      "display_name": "name",
      "documentation": "Globally unique name to use for this connector.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 2
      }
    },
    {
      "name": "connector.class",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 3,
      "display_name": "connector.class",
      "documentation": "Name or alias of the class for this connector. Must be a subclass of org.apache.kafka.connect.connector.Connector. If the connector is org.apache.kafka.connect.file.FileStreamSinkConnector, you can either specify this full name,  or use \u00e2\u0080\u009cFileStreamSink\u00e2\u0080\u009d or \u00e2\u0080\u009cFileStreamSinkConnector\u00e2\u0080\u009d to make the configuration a bit shorter",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 3
      }
    },
    {
      "name": "tasks.max",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 4,
      "display_name": "tasks.max",
      "documentation": "Maximum number of tasks to use for this connector.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 4
      }
    },
    {
      "name": "topics",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 5,
      "display_name": "topics",
      "documentation": "List of topics to consume, separated by commas",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 5
      }
    },
    {
      "name": "topics.regex",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 6,
      "display_name": "topics.regex",
      "documentation": "Regular expression giving topics to consume. Under the hood, the regex is compiled to ajava.util.regex.Pattern. Only one of topics or topics.regex should be specified.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 6
      }
    },
    {
      "name": "tasks.max.enforce",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 7,
      "display_name": "tasks.max.enforce",
      "documentation": "(Deprecated) Whether to enforce that the tasks.max property is respected by the connector. By default, connectors that generate too many tasks will fail, and existing sets of tasks that exceed the tasks.max property will also be failed. If this property is set to false, then connectors will be allowed to generate more than the maximum number of tasks, and existing sets of tasks that exceed the tasks.max property will be allowed to run. This property is deprecated and will be removed in an upcoming major release.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 7
      }
    },
    {
      "name": "key.converter",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 8,
      "display_name": "key.converter",
      "documentation": "Converter class used to convert between Kafka Connect format and the serialized form that is written to Kafka. This controls the format of the keys in messages written to or read from Kafka, and since this is independent of connectors it allows any connector to work with any serialization format. Examples of common formats include JSON and Avro.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 8
      }
    },
    {
      "name": "value.converter",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 9,
      "display_name": "value.converter",
      "documentation": "Converter class used to convert between Kafka Connect format and the serialized form that is written to Kafka. This controls the format of the values in messages written to or read from Kafka, and since this is independent of connectors it allows any connector to work with any serialization format. Examples of common formats include JSON and Avro.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 9
      }
    },
    {
      "name": "header.converter",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 10,
      "display_name": "header.converter",
      "documentation": "HeaderConverter class used to convert between Kafka Connect format and the serialized form that is written to Kafka. This controls the format of the header values in messages written to or read from Kafka, and since this is independent of connectors it allows any connector to work with any serialization format. Examples of common formats include JSON and Avro. By default, the SimpleHeaderConverter is used to serialize header values to strings and deserialize them by inferring the schemas.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 10
      }
    },
    {
      "name": "config.action.reload",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 11,
      "display_name": "config.action.reload",
      "documentation": "The action that Connect should take on the connector when changes in external configuration providers result in a change in the connector\u00e2\u0080\u0099s configuration properties. A value of \u00e2\u0080\u0098none\u00e2\u0080\u0099 indicates that Connect will do nothing. A value of \u00e2\u0080\u0098restart\u00e2\u0080\u0099 indicates that Connect should restart/reload the connector with the updated configuration properties.The restart may actually be scheduled in the future if the external configuration provider indicates that a configuration value will expire in the future.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 11
      }
    },
    {
      "name": "transforms",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 12,
      "display_name": "transforms",
      "documentation": "Aliases for the transformations to be applied to records.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 12
      }
    },
    {
      "name": "predicates",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 13,
      "display_name": "predicates",
      "documentation": "Aliases for the predicates used by transformations.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 13
      }
    },
    {
      "name": "errors.retry.timeout",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 14,
      "display_name": "errors.retry.timeout",
      "documentation": "The maximum duration in milliseconds that a failed operation will be reattempted. The default is 0, which means no retries will be attempted. Use -1 for infinite retries.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 14
      }
    },
    {
      "name": "errors.retry.delay.max.ms",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 15,
      "display_name": "errors.retry.delay.max.ms",
      "documentation": "The maximum duration in milliseconds between consecutive retry attempts. Jitter will be added to the delay once this limit is reached to prevent thundering herd issues.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 15
      }
    },
    {
      "name": "errors.tolerance",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 16,
      "display_name": "errors.tolerance",
      "documentation": "Behavior for tolerating errors during connector operation. \u00e2\u0080\u0098none\u00e2\u0080\u0099 is the default value and signals that any error will result in an immediate connector task failure; \u00e2\u0080\u0098all\u00e2\u0080\u0099 changes the behavior to skip over problematic records.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 16
      }
    },
    {
      "name": "errors.log.enable",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 17,
      "display_name": "errors.log.enable",
      "documentation": "If true, write each error and the details of the failed operation and problematic record to the Connect application log. This is \u00e2\u0080\u0098false\u00e2\u0080\u0099 by default, so that only errors that are not tolerated are reported.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 17
      }
    },
    {
      "name": "errors.log.include.messages",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 18,
      "display_name": "errors.log.include.messages",
      "documentation": "Whether to include in the log the Connect record that resulted in a failure. For sink records, the topic, partition, offset, and timestamp will be logged. For source records, the key and value (and their schemas), all headers, and the timestamp, Kafka topic, Kafka partition, source partition, and source offset will be logged. This is \u00e2\u0080\u0098false\u00e2\u0080\u0099 by default, which will prevent record keys, values, and headers from being written to log files.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 18
      }
    },
    {
      "name": "errors.deadletterqueue.topic.name",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 19,
      "display_name": "errors.deadletterqueue.topic.name",
      "documentation": "The name of the topic to be used as the dead letter queue (DLQ) for messages that result in an error when processed by this sink connector, or its transformations or converters. The topic name is blank by default, which means that no messages are to be recorded in the DLQ.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 19
      }
    },
    {
      "name": "errors.deadletterqueue.topic.replication.factor",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 20,
      "display_name": "errors.deadletterqueue.topic.replication.factor",
      "documentation": "Replication factor used to create the dead letter queue topic when it doesn\u00e2\u0080\u0099t already exist.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 20
      }
    },
    {
      "name": "errors.deadletterqueue.context.headers.enable",
      "type": "STRING",
      "required": false,
      "importance": "MEDIUM",
      "group": "Common",
      "order_in_group": 21,
      "display_name": "errors.deadletterqueue.context.headers.enable",
      "documentation": "If true, add headers containing error context to the messages written to the dead letter queue. To avoid clashing with headers from the original record, all error context header keys, all error context header keys will start with__connect.errors.",
      "validators": [],
      "sanitizers": [],
      "metadata": {
        "page": "CONFIGURATION",
        "order_in_page": 21
      }
    }
  ]
}