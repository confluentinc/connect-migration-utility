{
  "templates": [
    {
      "template_id": "MongoDbAtlasSource",
      "connector_type": "SOURCE",
      "connector.class": "com.mongodb.kafka.connect.MongoSourceConnector",
      "name": "{{.logicalClusterId}}",
      "imports": [
        "common",
        "common-kafka-connectivity",
        "topic-prefix-source",
        "schema-registry",
        "common-mongodb",
        "source-connector-output-data-format",
        "output-key-format"
      ],
      "group_order": [
        "How should we connect to your data?",
        "Kafka Cluster credentials",
        "Schema Config",
        "How do you want to name your topic(s)?",
        "How should we connect to your MongoDB Atlas database?",
        "Database details",
        "Connection details",
        "Producer configuration",
        "Output messages",
        "Error handling",
        "Server API",
        "Partition",
        "Number of tasks for this connector",
        "Additional Configs"
      ],
      "config_defs": [
        {
          "name": "output.data.format",
          "type": "STRING",
          "required": true,
          "importance": "HIGH",
          "default_value": "STRING",
          "group": "Output messages",
          "order_in_group": 1,
          "display_name": "Output Kafka record value format",
          "documentation": "Sets the output Kafka record value format. Valid entries are AVRO, JSON_SR, PROTOBUF, JSON, STRING or BSON. Note that you need to have Confluent Cloud Schema Registry configured if using a schema-based message format like AVRO, JSON_SR, and PROTOBUF",
          "recommended_values": [
            "AVRO",
            "JSON_SR",
            "PROTOBUF",
            "JSON",
            "STRING",
            "BSON"
          ],
          "validators": [
            {
              "name": "sr.integration"
            }
          ],
          "dependents": [
            "schema.registry.url"
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": false,
            "order_in_page": 1
          }
        },
        {
          "name": "publish.full.document.only",
          "type": "STRING",
          "required": false,
          "importance": "HIGH",
          "default_value": "false",
          "group": "Output messages",
          "order_in_group": 2,
          "display_name": "Publish full document only",
          "documentation": "Only publish the changed document instead of the full change stream document. Sets the change.stream.full.document=updateLookup automatically so updated documents will be included.",
          "recommended_values": [
            "true",
            "false"
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 2
          }
        },
        {
          "name": "publish.full.document.only.tombstone.on.delete",
          "type": "STRING",
          "required": false,
          "importance": "HIGH",
          "default_value": "false",
          "group": "Output messages",
          "order_in_group": 3,
          "display_name": "Publish tombstone events on documents deletion",
          "documentation": "Return the tombstone events when documents are deleted. Tombstone events contain the keys of deleted documents with null values. This setting applies only when publish.full.document.only is true",
          "recommended_values": [
            "true",
            "false"
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 3
          }
        },
        {
          "name": "change.stream.full.document",
          "type": "STRING",
          "required": false,
          "importance": "HIGH",
          "default_value": "default",
          "group": "Output messages",
          "order_in_group": 4,
          "display_name": "Change stream full document",
          "documentation": "Determines what to return for update operations when using a Change Stream. When set to 'updateLookup' setting returns the differences between the original document and updated document as well as a copy of the entire updated document at a point in time after the update. The 'whenAvailable' setting returns the updated document, if available. The 'required' setting returns the updated document and raises an error if it is not available.",
          "recommended_values": [
            "default",
            "updateLookup",
            "whenAvailable",
            "required"
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 4
          }
        },
        {
          "name": "change.stream.full.document.before.change",
          "type": "STRING",
          "required": false,
          "importance": "HIGH",
          "default_value": "default",
          "group": "Output messages",
          "order_in_group": 5,
          "display_name": "Change stream full document before change",
          "documentation": "Configures the document pre-image your change stream returns on update operations. When set to 'whenAvailable' setting returns the document pre-image if it's available, before it was replaced, updated, or deleted. When set to 'required' setting returns the document pre-image and raises an error if it is not available.",
          "recommended_values": [
            "default",
            "whenAvailable",
            "required"
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 5
          }
        },
        {
          "name": "output.json.format",
          "type": "STRING",
          "required": false,
          "importance": "HIGH",
          "default_value": "DefaultJson",
          "group": "Output messages",
          "order_in_group": 6,
          "display_name": "Output json formatter",
          "documentation": "The output format of json strings can be configured to be either: DefaultJson: The legacy strict json formatter. ExtendedJson: The fully type safe extended json formatter. SimplifiedJson: Simplified Json, with ObjectId, Decimals, Dates and Binary values represented as strings. Users can provide their own implementation of the com.mongodb.kafka.connect.source.json.formatter.",
          "recommended_values": [
            "DefaultJson",
            "ExtendedJson",
            "SimplifiedJson"
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 6
          }
        },
        {
          "name": "topic.separator",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "default_value": ".",
          "group": "Output messages",
          "order_in_group": 7,
          "display_name": "Topic separator",
          "documentation": "Separator to use when joining prefix, database, collection, and suffix values. This generates the name of the Kafka topic to publish data to. Used by the 'DefaultTopicMapper'.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 7
          }
        },
        {
          "name": "topic.suffix",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "group": "Output messages",
          "order_in_group": 8,
          "display_name": "Topic suffix",
          "documentation": "Suffix to append to database and collection names to generate the name of the Kafka topic to publish data to.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 8
          }
        },
        {
          "name": "output.schema.infer.value",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "default_value": "true",
          "group": "Output messages",
          "order_in_group": 10,
          "display_name": "Output schema infer value",
          "documentation": "Whether the connector should infer the schema for the value document of the Source Record.  Since the connector processes each document in isolation, the connector may generate many schemas. The connector only reads this setting when you set your 'Output Kafka record value format' setting to AVRO, JSON, JSON_SR and PROTOBUF.",
          "recommended_values": [
            "true",
            "false"
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 27
          }
        },
        {
          "name": "topic.prefix",
          "type": "STRING",
          "required": false,
          "importance": "HIGH",
          "group": "How do you want to name your topic(s)?",
          "order_in_group": 1,
          "display_name": "Topic prefix",
          "metadata": {
            "page": "SELECT_TOPICS",
            "order_in_page": 1,
            "documentation": "Your connector will publish to kafka topics using the prefix provided. The connector automatically creates Kafka topics using the naming convention: <prefix>.<database-name>.<collection-name>."
          }
        },
        {
          "name": "topic.namespace.map",
          "type": "STRING",
          "required": false,
          "default_value": "",
          "importance": "LOW",
          "group": "How do you want to name your topic(s)?",
          "order_in_group": 2,
          "display_name": "Topic namespace map",
          "metadata": {
            "page": "CONFIGURATION",
            "order_in_page": 2,
            "advanced": "true"
          },
          "documentation": "JSON object that maps change stream document namespaces to topics. Any prefix configuration will still apply. In case multiple collections with records having varying schema are mapped to single topic with AVRO, JSON_SR, and PROTOBUF, then multiple schemas will be registered under single subject name. If these schemas are not backward compatible to each other, the connector will fail until you change the schema compatibility in Confluent Cloud Schema Registry."
        },
        {
          "name": "connection.host",
          "type": "STRING",
          "required": true,
          "default_value": "",
          "importance": "HIGH",
          "group": "How should we connect to your MongoDB Atlas database?",
          "order_in_group": 1,
          "display_name": "Connection host",
          "documentation": "MongoDB Atlas connection host (e.g. confluent-test.mycluster.mongodb.net).",
          "sanitizers": [
            {
              "name": "trim"
            }
          ],
          "validators": [
            {
              "name": "mongodb.connection.string"
            }
          ],
          "metadata": {
            "page": "AUTHENTICATION",
            "advanced": false,
            "group_name": "MongoDB Atlas database details",
            "order_in_page": 1
          }
        },
        {
          "name": "connector.endpoint",
          "type": "STRING",
          "required": false,
          "importance": "HIGH",
          "default_value": null,
          "internal": true,
          "custom_config_provider": {
            "name": "mongo.db.atlas.mapper.endpoint"
          }
        },
        {
          "name": "connection.user",
          "type": "STRING",
          "required": true,
          "importance": "HIGH",
          "group": "How should we connect to your MongoDB Atlas database?",
          "order_in_group": 2,
          "display_name": "Connection user",
          "documentation": "MongoDB Atlas connection user.",
          "sanitizers": [
            {
              "name": "trim"
            }
          ],
          "metadata": {
            "page": "AUTHENTICATION",
            "advanced": false,
            "group_name": "MongoDB Atlas database details",
            "order_in_page": 2
          }
        },
        {
          "name": "connection.password",
          "type": "PASSWORD",
          "required": true,
          "importance": "HIGH",
          "group": "How should we connect to your MongoDB Atlas database?",
          "order_in_group": 3,
          "display_name": "Connection password",
          "documentation": "MongoDB Atlas connection password.",
          "metadata": {
            "page": "AUTHENTICATION",
            "advanced": false,
            "group_name": "MongoDB Atlas database details",
            "order_in_page": 3
          }
        },
        {
          "name": "database",
          "type": "STRING",
          "required": false,
          "importance": "HIGH",
          "group": "How should we connect to your MongoDB Atlas database?",
          "order_in_group": 4,
          "display_name": "Database name",
          "documentation": "MongoDB Atlas database name. If not set, all databases in the cluster are watched.",
          "metadata": {
            "page": "AUTHENTICATION",
            "advanced": true,
            "group_name": "MongoDB Atlas database details",
            "order_in_page": 4
          }
        },
        {
          "name": "collection",
          "type": "STRING",
          "required": false,
          "importance": "MEDIUM",
          "group": "Database details",
          "order_in_group": 1,
          "display_name": "Collection name",
          "documentation": "Single MongoDB Atlas collection to watch. If not set, all collections in the specified database are watched.",
          "metadata": {
            "page": "AUTHENTICATION",
            "advanced": true,
            "group_name": "Database details",
            "order_in_page": 5
          }
        },
        {
          "name": "poll.await.time.ms",
          "type": "INT",
          "required": false,
          "default_value": "5000",
          "importance": "LOW",
          "group": "Connection details",
          "order_in_group": 1,
          "display_name": "Poll wait time (ms)",
          "documentation": "The amount of time to wait before checking for new results on the change stream.",
          "validators": [
            {
              "name": "common.range",
              "arguments": {
                "min": 1
              }
            }
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 7,
            "group_name": "Connection details"
          }
        },
        {
          "name": "poll.max.batch.size",
          "type": "INT",
          "required": false,
          "default_value": "100",
          "importance": "LOW",
          "group": "Connection details",
          "order_in_group": 2,
          "display_name": "Maximum documents to include in a batch",
          "documentation": "Maximum number of change stream documents to include in a single batch when polling for new data. This setting can be used to limit the amount of data buffered internally in the connector.",
          "validators": [
            {
              "name": "common.range",
              "arguments": {
                "min": 1,
                "max": 1000
              }
            }
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 8,
            "group_name": "Connection details"
          }
        },
        {
          "name": "pipeline",
          "type": "STRING",
          "required": false,
          "default_value": "[]",
          "importance": "MEDIUM",
          "group": "Connection details",
          "order_in_group": 3,
          "display_name": "Pipeline",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 9,
            "group_name": "Connection details"
          },
          "documentation": "An array of JSON objects describing the pipeline operations to filter or modify the change events output. For example, [{\"$match\": {\"ns.coll\": {\"$regex\": /^(collection1|collection2)$/}}}] will set your source connector to listen to the \"collection1\" and \"collection2\" collections only."
        },
        {
          "name": "copy.existing",
          "type": "STRING",
          "required": false,
          "default_value": "false",
          "importance": "HIGH",
          "group": "Connection details",
          "order_in_group": 4,
          "internal": true,
          "display_name": "Copy existing data",
          "documentation": "Whether to copy existing data from source collections. Setting this to true may cause record duplications.",
          "recommended_values": [
            "true",
            "false"
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 10,
            "group_name": "Connection details"
          }
        },
        {
          "name": "startup.mode",
          "type": "STRING",
          "required": false,
          "default_value": "",
          "importance": "HIGH",
          "group": "Connection details",
          "order_in_group": 5,
          "display_name": "Startup mode",
          "documentation": "Specifies how the connector should start up when there is no source offset available. If set to 'latest', the connector ignores all existing source data. If set to 'timestamp', the connector actuates startup.mode.timestamp.* properties. If no properties are configured, timestamp is equivalent to latest. If startup.mode=copy_existing, the connector copies all existing source data to Change Stream events.",
          "recommended_values": [
            "latest",
            "timestamp",
            "copy_existing"
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 11,
            "group_name": "Connection details"
          }
        },
        {
          "name": "copy.existing.namespace.regex",
          "type": "STRING",
          "required": false,
          "default_value": "",
          "importance": "MEDIUM",
          "group": "Connection details",
          "order_in_group": 6,
          "internal": true,
          "display_name": "Copy existing namespace regex",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 12,
            "group_name": "Connection details"
          },
          "documentation": "Regular expression that matches the namespaces (databaseName.collectionName) from which to copy data. For example, stats\\.page.* matches all collections that starts with \"page\" in \"stats\" database."
        },
        {
          "name": "startup.mode.copy.existing.namespace.regex",
          "type": "STRING",
          "required": false,
          "default_value": "",
          "importance": "MEDIUM",
          "group": "Connection details",
          "order_in_group": 7,
          "display_name": "Copy existing namespace regex",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 13,
            "group_name": "Connection details"
          },
          "documentation": "Regular expression that matches the namespaces (databaseName.collectionName) from which to copy data. For example, stats\\.page.* matches all collections that starts with \"page\" in \"stats\" database."
        },
        {
          "name": "copy.existing.pipeline",
          "type": "STRING",
          "required": false,
          "default_value": "[]",
          "importance": "MEDIUM",
          "group": "Connection details",
          "order_in_group": 8,
          "internal": true,
          "display_name": "Copy existing pipeline",
          "documentation": "An array of JSON objects describing the pipeline operations to run when copying existing data. It will only be applied for existing documents which are being copied.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 14,
            "group_name": "Connection details"
          }
        },
        {
          "name": "startup.mode.copy.existing.pipeline",
          "type": "STRING",
          "required": false,
          "default_value": "",
          "importance": "MEDIUM",
          "group": "Connection details",
          "order_in_group": 9,
          "display_name": "Copy existing pipeline",
          "documentation": "An array of JSON objects describing the pipeline operations to run when copying existing data. It will only be applied for existing documents which are being copied.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 15,
            "group_name": "Connection details"
          }
        },
        {
          "name": "startup.mode.timestamp.start.at.operation.time",
          "type": "STRING",
          "required": false,
          "default_value": "",
          "importance": "MEDIUM",
          "group": "Connection details",
          "order_in_group": 10,
          "display_name": "Start timestamp",
          "documentation": "Actuated only if startup.mode=timestamp. Specifies the starting point for the change stream.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 16,
            "group_name": "Connection details"
          }
        },
        {
          "name": "batch.size",
          "type": "INT",
          "required": false,
          "default_value": "0",
          "importance": "LOW",
          "group": "Connection details",
          "order_in_group": 11,
          "display_name": "Cursor batch size",
          "documentation": "The number of documents to return in a batch.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 17,
            "group_name": "Connection details"
          },
          "validators": [
            {
              "name": "common.range",
              "arguments": {
                "max": 50
              }
            }
          ]
        },
        {
          "name": "output.schema.key",
          "type": "STRING",
          "required": false,
          "default_value": "{ \"type\": \"record\", \"name\": \"keySchema\", \"fields\": [{ \"name\": \"_id\", \"type\": \"string\"}]}",
          "importance": "MEDIUM",
          "group": "Connection details",
          "order_in_group": 12,
          "display_name": "Output Schema Key",
          "documentation": "The Avro schema definition for the key value of the SourceRecord.",
          "validators": [
            {
              "name": "common.length",
              "arguments": {
                "length": 100000
              }
            }
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 29,
            "group_name": "Connection details"
          }
        },
        {
          "name": "output.schema.value",
          "type": "STRING",
          "required": false,
          "default_value": "{\"name\": \"ChangeStream\", \"type\": \"record\", \"fields\": [{\"name\": \"_id\", \"type\": \"string\"}, {\"name\": \"operationType\", \"type\": [\"string\", \"null\"]}, {\"name\": \"fullDocumentBeforeChange\", \"type\": [\"string\", \"null\"]}, {\"name\": \"fullDocument\", \"type\": [\"string\", \"null\"]}, {\"name\": \"ns\", \"type\": [{\"name\": \"ns\", \"type\": \"record\", \"fields\": [{\"name\": \"db\", \"type\": \"string\"}, {\"name\": \"coll\", \"type\": [\"string\", \"null\"]}]}, \"null\"]}, {\"name\": \"to\", \"type\": [{\"name\": \"to\", \"type\": \"record\", \"fields\": [{\"name\": \"db\", \"type\": \"string\"}, {\"name\": \"coll\", \"type\": [\"string\", \"null\"]}]}, \"null\"]}, {\"name\": \"documentKey\", \"type\": [\"string\", \"null\"]}, {\"name\": \"updateDescription\", \"type\": [{\"name\": \"updateDescription\", \"type\": \"record\", \"fields\": [{\"name\": \"updatedFields\", \"type\": [\"string\", \"null\"]}, {\"name\": \"removedFields\", \"type\": [{\"type\": \"array\", \"items\": \"string\"}, \"null\"]}]}, \"null\"]}, {\"name\": \"clusterTime\", \"type\": [\"string\", \"null\"]}, {\"name\": \"txnNumber\", \"type\": [\"long\", \"null\"]}, {\"name\": \"lsid\", \"type\": [{\"name\": \"lsid\", \"type\": \"record\", \"fields\": [{\"name\": \"id\", \"type\": \"string\"}, {\"name\": \"uid\", \"type\": \"string\"}]}, \"null\"]}]}",
          "importance": "MEDIUM",
          "group": "Connection details",
          "order_in_group": 13,
          "display_name": "Output Schema Value",
          "documentation": "The Avro schema definition for the value of the SourceRecord.",
          "validators": [
            {
              "name": "common.length",
              "arguments": {
                "length": 100000
              }
            }
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 30,
            "group_name": "Connection details"
          }
        },
        {
          "name": "heartbeat.interval.ms",
          "type": "INT",
          "required": false,
          "default_value": "0",
          "importance": "MEDIUM",
          "group": "Error handling",
          "order_in_group": 1,
          "display_name": "Heartbeat interval",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 18,
            "group_name": "Error handling"
          },
          "documentation": "The number of milliseconds the connector waits between sending heartbeat messages. The connector sends heartbeat messages when source records are not published in the specified interval. This mechanism improves resumability of the connector for low volume namespaces. When using SMTs, use predicates to prevent SMTs from processing the heartbeat messages. See connector documentation for more details."
        },
        {
          "name": "heartbeat.topic.name",
          "type": "STRING",
          "required": false,
          "default_value": "__mongodb_heartbeats",
          "importance": "MEDIUM",
          "group": "Error handling",
          "order_in_group": 2,
          "display_name": "Heartbeat topic name",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 19,
            "group_name": "Error handling"
          },
          "documentation": "The name of the topic on which the connector should publish heartbeat messages. You must provide a positive value in the \"heartbeat.interval.ms\" setting to enable this feature."
        },
        {
          "name": "mongo.errors.tolerance",
          "type": "STRING",
          "required": false,
          "default_value": "NONE",
          "importance": "MEDIUM",
          "group": "Error handling",
          "order_in_group": 4,
          "display_name": "Error tolerance",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 20,
            "group_name": "Error handling Mongo"
          },
          "recommended_values": [
            "NONE",
            "ALL"
          ],
          "documentation": "Use this property if you would like to configure the connector's error handling behavior differently from the Connect framework's."
        },
        {
          "name": "mongo.errors.deadletterqueue.topic.name",
          "type": "STRING",
          "required": false,
          "importance": "MEDIUM",
          "group": "Error handling",
          "order_in_group": 5,
          "display_name": "Output errors",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 21,
            "group_name": "Error handling Mongo"
          },
          "documentation": "Whether to output conversion errors to the dead letter queue. Stops poison messages when using schemas, any message will be outputted as extended json on the specified topic. By default messages are not outputted to the dead letter queue. Also requires errors.tolerance=all."
        },
        {
          "name": "server.api.version",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "group": "Server API",
          "order_in_group": 1,
          "display_name": "Server API version",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 22,
            "group_name": "Server API"
          },
          "documentation": "The server API version to use. Disabled by default."
        },
        {
          "name": "server.api.deprecation.errors",
          "type": "STRING",
          "required": false,
          "default_value": "false",
          "importance": "LOW",
          "group": "Server API",
          "order_in_group": 2,
          "display_name": "Deprecation errors",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 23,
            "group_name": "Server API"
          },
          "recommended_values": [
            "true",
            "false"
          ],
          "documentation": "Sets whether the connector requires use of deprecated server APIs to be reported as errors."
        },
        {
          "name": "server.api.strict",
          "type": "STRING",
          "required": false,
          "default_value": "false",
          "importance": "LOW",
          "group": "Server API",
          "order_in_group": 3,
          "display_name": "Strict",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 24,
            "group_name": "Server API"
          },
          "recommended_values": [
            "true",
            "false"
          ],
          "documentation": "Sets whether the application requires strict server API version enforcement."
        },
        {
          "name": "offset.partition.name",
          "type": "STRING",
          "required": false,
          "default_value": "",
          "importance": "MEDIUM",
          "group": "Error handling",
          "order_in_group": 3,
          "display_name": "Offset partition name",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 28,
            "group_name": "Error handling"
          },
          "documentation": "The custom offset partition name to use. You can use this option to instruct the connector to start a new change stream when an existing offset contains an invalid resume token. If you leave this setting blank, the connector uses the default partition name based on the connection details."
        },
        {
          "name": "tasks.max",
          "type": "INT",
          "required": true,
          "importance": "HIGH",
          "group": "Number of tasks for this connector",
          "order_in_group": 1,
          "display_name": "Tasks",
          "documentation": "Maximum number of tasks for the connector.",
          "validators": [
            {
              "name": "common.range",
              "arguments": {
                "min": 1,
                "max": 1
              }
            }
          ]
        },
        {
          "name": "linger.ms",
          "type": "LONG",
          "required": "false",
          "importance": "MEDIUM",
          "group": "Producer configuration",
          "order_in_group": 1,
          "display_name": "Producer linger(ms)",
          "default_value": 0,
          "documentation": "Artificial delay for records to be sent together.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 25,
            "group_name": "Producer configuration"
          },
          "validators": [
            {
              "name": "common.range",
              "arguments": {
                "min": 0,
                "max": 20000
              }
            }
          ]
        },
        {
          "name": "producer.batch.size",
          "type": "INT",
          "required": "false",
          "importance": "MEDIUM",
          "group": "Producer configuration",
          "order_in_group": 2,
          "display_name": "Producer batch size(bytes)",
          "default_value": 16384,
          "documentation": "Record batch size in bytes.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 26,
            "group_name": "Producer configuration"
          },
          "validators": [
            {
              "name": "common.range",
              "arguments": {
                "min": 0,
                "max": 491520
              }
            }
          ]
        }
      ],
      "connector_configs": [
        {
          "name": "consumer.override.sasl.jaas.config",
          "value": "org.apache.kafka.common.security.plain.PlainLoginModule required username=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.key}\" password=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.secret}\";"
        },
        {
          "name": "consumer.override.security.protocol",
          "value": "SASL_SSL"
        },
        {
          "name": "consumer.override.sasl.mechanism",
          "value": "PLAIN"
        },
        {
          "name": "producer.override.sasl.jaas.config",
          "value": "org.apache.kafka.common.security.plain.PlainLoginModule required username=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.key}\" password=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.secret}\";"
        },
        {
          "name": "producer.override.security.protocol",
          "value": "SASL_SSL"
        },
        {
          "name": "producer.override.sasl.mechanism",
          "value": "PLAIN"
        },
        {
          "name": "admin.override.sasl.jaas.config",
          "value": "org.apache.kafka.common.security.plain.PlainLoginModule required username=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.key}\" password=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.secret}\";"
        },
        {
          "name": "admin.override.security.protocol",
          "value": "SASL_SSL"
        },
        {
          "name": "admin.override.sasl.mechanism",
          "value": "PLAIN"
        },
        {
          "name": "producer.override.max.request.size",
          "switch": {
            "kafka.dedicated": {
              "true": "20971610",
              "false": "8388608"
            }
          }
        },
        {
          "name": "topic.creation.default.max.message.bytes",
          "switch": {
            "kafka.dedicated": {
              "true": "20971520",
              "false": "2097152"
            }
          }
        },
        {
          "name": "value.converter",
          "switch": {
            "output.data.format": {
              "AVRO": "io.confluent.connect.avro.AvroConverter",
              "JSON_SR": "io.confluent.connect.json.JsonSchemaConverter",
              "PROTOBUF": "io.confluent.connect.protobuf.ProtobufConverter",
              "JSON": "org.apache.kafka.connect.json.JsonConverter",
              "STRING": "org.apache.kafka.connect.storage.StringConverter",
              "BSON": "org.apache.kafka.connect.converters.ByteArrayConverter"
            }
          }
        },
        {
          "name": "output.format.value",
          "switch": {
            "output.data.format": {
              "AVRO": "schema",
              "JSON": "schema",
              "JSON_SR": "schema",
              "PROTOBUF": "schema",
              "STRING": "json",
              "BSON": "bson"
            }
          }
        },
        {
          "name": "output.format.key",
          "switch": {
            "output.data.format": {
              "AVRO": "schema",
              "JSON": "schema",
              "JSON_SR": "schema",
              "PROTOBUF": "schema",
              "STRING": "json",
              "BSON": "bson"
            }
          }
        },
        {
          "name": "output.schema.infer.value"
        },
        {
          "name": "value.converter.schema.registry.url",
          "switch": {
            "output.data.format": {
              "AVRO": "${schema.registry.url}",
              "JSON_SR": "${schema.registry.url}",
              "PROTOBUF": "${schema.registry.url}"
            }
          }
        },
        {
          "name": "value.converter.basic.auth.credentials.source",
          "switch": {
            "output.data.format": {
              "AVRO": "USER_INFO",
              "JSON_SR": "USER_INFO",
              "PROTOBUF": "USER_INFO"
            }
          }
        },
        {
          "name": "value.converter.basic.auth.user.info",
          "switch": {
            "output.data.format": {
              "AVRO": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}",
              "JSON_SR": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}",
              "PROTOBUF": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}"
            }
          }
        },
        {
          "name": "topic.prefix"
        },
        {
          "name": "topic.namespace.map"
        },
        {
          "name": "tasks.max",
          "value": "1"
        },
        {
          "name": "connection.uri",
          "switch": {
            "connection.host": {
              "": null,
              "DEFAULT": "mongodb+srv://${connection.user}:${connection.password}@${connection.host}"
            }
          }
        },
        {
          "name": "database"
        },
        {
          "name": "collection"
        },
        {
          "name": "poll.await.time.ms"
        },
        {
          "name": "publish.full.document.only"
        },
        {
          "name": "publish.full.document.only.tombstone.on.delete"
        },
        {
          "name": "change.stream.full.document"
        },
        {
          "name": "change.stream.full.document.before.change"
        },
        {
          "name": "output.json.formatter",
          "switch": {
            "output.json.format": {
              "DefaultJson": "com.mongodb.kafka.connect.source.json.formatter.DefaultJson",
              "ExtendedJson": "com.mongodb.kafka.connect.source.json.formatter.ExtendedJson",
              "SimplifiedJson": "com.mongodb.kafka.connect.source.json.formatter.SimplifiedJson"
            }
          }
        },
        {
          "name": "poll.max.batch.size"
        },
        {
          "name": "pipeline"
        },
        {
          "name": "copy.existing"
        },
        {
          "name": "copy.existing.namespace.regex"
        },
        {
          "name": "copy.existing.pipeline"
        },
        {
          "name": "startup.mode"
        },
        {
          "name": "startup.mode.copy.existing.namespace.regex"
        },
        {
          "name": "startup.mode.copy.existing.pipeline"
        },
        {
          "name": "startup.mode.timestamp.start.at.operation.time"
        },
        {
          "name": "topic.separator"
        },
        {
          "name": "topic.suffix"
        },
        {
          "name": "batch.size"
        },
        {
          "name": "mongo.errors.tolerance"
        },
        {
          "name": "mongo.errors.deadletterqueue.topic.name"
        },
        {
          "name": "server.api.version"
        },
        {
          "name": "server.api.deprecation.errors"
        },
        {
          "name": "server.api.strict"
        },
        {
          "name": "startup.mode.copy.existing.queue.size",
          "value": "100"
        },
        {
          "name": "startup.mode.copy.existing.max.threads",
          "value": "1"
        },
        {
          "name": "startup.mode.copy.existing.allow.disk.use",
          "value": "true"
        },
        {
          "name": "schema.cache.size",
          "value": "1000"
        },
        {
          "name": "enhanced.avro.schema.support",
          "value": "true"
        },
        {
          "name": "locale",
          "value": "en"
        },
        {
          "name": "timezone",
          "value": "UTC"
        },
        {
          "name": "rotate.interval.ms",
          "value": "86400000"
        },
        {
          "name": "timestamp.extractor",
          "value": "Record"
        },
        {
          "name": "behavior.on.null.values",
          "value": "ignore"
        },
        {
          "name": "provider",
          "value": "confluent-cloud"
        },
        {
          "name": "heartbeat.interval.ms"
        },
        {
          "name": "heartbeat.topic.name"
        },
        {
          "name": "connector.endpoint"
        },
        {
          "name": "offset.partition.name"
        },
        {
          "name": "producer.override.linger.ms",
          "value": "${linger.ms}"
        },
        {
          "name": "producer.override.batch.size",
          "value": "${producer.batch.size}"
        },
        {
          "name": "output.schema.key"
        },
        {
          "name": "output.schema.value"
        },
        {
          "name": "mongo.errors.log.enable",
          "value": "true"
        }
      ]
    },
    {
      "template_id": "common",
      "global_validators": [
        {
          "name": "required",
          "priority": "HIGHEST"
        },
        {
          "name": "recommended.values",
          "priority": "HIGHER"
        }
      ],
      "abstract": true,
      "config_defs": [
        {
          "name": "connector.class",
          "type": "STRING",
          "required": true,
          "importance": "HIGH",
          "group": "How should we connect to your data?",
          "order_in_group": 1,
          "display_name": "Connector class",
          "metadata": {
            "page": "REVIEW_AND_LAUNCH",
            "order_in_page": 1,
            "change_after_launch": false
          }
        },
        {
          "name": "name",
          "type": "STRING",
          "required": true,
          "importance": "HIGH",
          "group": "How should we connect to your data?",
          "order_in_group": 2,
          "display_name": "Connector name",
          "documentation": "Sets a name for your connector.",
          "metadata": {
            "page": "REVIEW_AND_LAUNCH",
            "order_in_page": 2,
            "change_after_launch": false
          },
          "validators": [
            {
              "name": "common.length",
              "arguments": {
                "length": 64
              }
            }
          ]
        },
        {
          "name": "tasks.max",
          "type": "INT",
          "required": true,
          "importance": "HIGH",
          "group": "Number of tasks for this connector",
          "order_in_group": 1,
          "display_name": "Tasks",
          "documentation": "Maximum number of tasks for the connector.",
          "validators": [
            {
              "name": "common.range",
              "arguments": {
                "min": 1
              }
            }
          ],
          "metadata": {
            "page": "SIZING",
            "order_in_page": 1
          }
        },
        {
          "name": "kafka.auth.mode",
          "type": "STRING",
          "required": false,
          "default_value": "KAFKA_API_KEY",
          "importance": "HIGH",
          "group": "Kafka Cluster credentials",
          "order_in_group": 1,
          "display_name": "Kafka Cluster Authentication mode",
          "documentation": "Kafka Authentication mode. It can be one of KAFKA_API_KEY or SERVICE_ACCOUNT. It defaults to KAFKA_API_KEY mode.",
          "recommended_values": [
            "SERVICE_ACCOUNT",
            "KAFKA_API_KEY"
          ],
          "validators": [
            {
              "name": "common.is.recommended.value"
            }
          ],
          "metadata": {
            "page": "KAFKA_CREDENTIALS",
            "order_in_page": 1
          }
        },
        {
          "name": "kafka.api.key",
          "type": "PASSWORD",
          "required": false,
          "importance": "HIGH",
          "group": "Kafka Cluster credentials",
          "order_in_group": 2,
          "display_name": "Kafka API Key",
          "documentation": "Kafka API Key. Required when kafka.auth.mode==KAFKA_API_KEY.",
          "validators": [
            {
              "name": "common.conditional.required",
              "arguments": {
                "condition": "kafka.auth.mode==KAFKA_API_KEY"
              },
              "priority": "HIGHEST"
            },
            {
              "name": "kafka.credentials.sanity"
            }
          ],
          "metadata": {
            "page": "KAFKA_CREDENTIALS",
            "order_in_page": 2,
            "visibility": "kafka.auth.mode==KAFKA_API_KEY"
          }
        },
        {
          "name": "kafka.service.account.api.key",
          "type": "PASSWORD",
          "importance": "HIGH",
          "internal": true
        },
        {
          "name": "kafka.service.account.api.secret",
          "type": "PASSWORD",
          "importance": "HIGH",
          "internal": true
        },
        {
          "name": "kafka.region",
          "type": "STRING",
          "importance": "HIGH",
          "internal": true
        },
        {
          "name": "kafka.endpoint",
          "type": "STRING",
          "required": true,
          "importance": "HIGH",
          "internal": true,
          "validators": [
            {
              "name": "common.regex",
              "arguments": {
                "pattern": "^.*://.*$"
              }
            }
          ]
        },
        {
          "name": "kafka.user.id",
          "type": "INT",
          "required": false,
          "internal": true,
          "importance": "MEDIUM"
        },
        {
          "name": "cloud.environment",
          "type": "STRING",
          "required": true,
          "importance": "LOW",
          "internal": true
        },
        {
          "name": "connector.cloud",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "internal": true
        },
        {
          "name": "kafka.dedicated",
          "type": "STRING",
          "required": true,
          "importance": "LOW",
          "internal": true
        },
        {
          "name": "valid.kafka.api.key",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "internal": true
        },
        {
          "name": "kafka.service.account.oauth.token",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "internal": true
        },
        {
          "name": "kafka.logical.cluster.id",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "internal": true
        },
        {
          "name": "connect.connector_cross_region.enable",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "internal": true
        },
        {
          "name": "connector.regional.connectivity.enabled",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "internal": true
        },
        {
          "name": "sr.internal.sa.api.key",
          "type": "PASSWORD",
          "required": false,
          "importance": "LOW",
          "internal": true
        },
        {
          "name": "sr.internal.sa.api.secret",
          "type": "PASSWORD",
          "required": false,
          "importance": "LOW",
          "internal": true
        },
        {
          "name": "sr.internal.sa.validity.check",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "internal": true
        }
      ],
      "connector_configs": [
        {
          "name": "tasks.max"
        },
        {
          "name": "confluent.topic.bootstrap.servers",
          "value": "Placeholder value to pass connector validations"
        },
        {
          "name": "errors.log.enable",
          "value": "true"
        },
        {
          "name": "errors.log.include.messages",
          "value": "false"
        },
        {
          "name": "errors.retry.timeout",
          "value": "300000"
        },
        {
          "name": "errors.retry.delay.max.ms",
          "value": "30000"
        },
        {
          "name": "value.converter.ignore.modern.dialects",
          "value": "true"
        }
      ]
    },
    {
      "template_id": "common-kafka-connectivity",
      "abstract": true,
      "config_defs": [
        {
          "name": "connect.metadata_property.kafka.itsl.embed.lkc",
          "type": "STRING",
          "required": false,
          "default_value": "SKIP",
          "importance": "HIGH",
          "internal": true
        },
        {
          "name": "connect.metadata_property.kafka.itsl.ssl.endpoint.identification.algorithm",
          "type": "STRING",
          "required": false,
          "default_value": "UNSET",
          "importance": "HIGH",
          "internal": true
        },
        {
          "name": "connect.metadata_property.kafka.itsl.bootstrap.servers",
          "type": "STRING",
          "required": false,
          "default_value": "UNSET",
          "importance": "HIGH",
          "internal": true
        },
        {
          "name": "connect.fips.provider",
          "type": "STRING",
          "required": false,
          "default_value": "UNSET",
          "default_value_provider": {
            "name": "defaultvalue.fips.provider"
          },
          "importance": "HIGH",
          "internal": true
        }
      ],
      "connector_configs": [
        {
          "name": "consumer.override.bootstrap.servers",
          "switch": {
            "connect.metadata_property.kafka.itsl.bootstrap.servers": {
              "UNSET": "${kafka.endpoint}",
              "DEFAULT": "${connect.metadata_property.kafka.itsl.bootstrap.servers}"
            }
          }
        },
        {
          "name": "producer.override.bootstrap.servers",
          "switch": {
            "connect.metadata_property.kafka.itsl.bootstrap.servers": {
              "UNSET": "${kafka.endpoint}",
              "DEFAULT": "${connect.metadata_property.kafka.itsl.bootstrap.servers}"
            }
          }
        },
        {
          "name": "admin.override.bootstrap.servers",
          "switch": {
            "connect.metadata_property.kafka.itsl.bootstrap.servers": {
              "UNSET": "${kafka.endpoint}",
              "DEFAULT": "${connect.metadata_property.kafka.itsl.bootstrap.servers}"
            }
          }
        },
        {
          "name": "admin.override.ssl.trustmanager.algorithm",
          "switch": {
            "connect.metadata_property.kafka.itsl.ssl.endpoint.identification.algorithm": {
              "SECURED": "ConfluentTls",
              "DEFAULT": "PKIX"
            }
          }
        },
        {
          "name": "producer.override.ssl.trustmanager.algorithm",
          "switch": {
            "connect.metadata_property.kafka.itsl.ssl.endpoint.identification.algorithm": {
              "SECURED": "ConfluentTls",
              "DEFAULT": "PKIX"
            }
          }
        },
        {
          "name": "consumer.override.ssl.trustmanager.algorithm",
          "switch": {
            "connect.metadata_property.kafka.itsl.ssl.endpoint.identification.algorithm": {
              "SECURED": "ConfluentTls",
              "DEFAULT": "PKIX"
            }
          }
        },
        {
          "name": "admin.override.ssl.endpoint.identification.algorithm",
          "switch": {
            "connect.metadata_property.kafka.itsl.ssl.endpoint.identification.algorithm": {
              "UNSECURED_PREPROD_ONLY": "",
              "SECURED": "",
              "DEFAULT": "https"
            }
          }
        },
        {
          "name": "producer.override.ssl.endpoint.identification.algorithm",
          "switch": {
            "connect.metadata_property.kafka.itsl.ssl.endpoint.identification.algorithm": {
              "UNSECURED_PREPROD_ONLY": "",
              "SECURED": "",
              "DEFAULT": "https"
            }
          }
        },
        {
          "name": "consumer.override.ssl.endpoint.identification.algorithm",
          "switch": {
            "connect.metadata_property.kafka.itsl.ssl.endpoint.identification.algorithm": {
              "UNSECURED_PREPROD_ONLY": "",
              "SECURED": "",
              "DEFAULT": "https"
            }
          }
        },
        {
          "name": "admin.override.security.providers",
          "switch": {
            "connect.fips.provider": {
              "BCJSSE": "io.confluent.kafka.security.fips.provider.BcFipsProviderCreator,io.confluent.kafka.security.fips.provider.BcFipsJsseProviderCreator,io.confluent.kafka.server.plugins.ssl.ConfluentTrustProviderCreator",
              "DEFAULT": null
            }
          }
        },
        {
          "name": "producer.override.security.providers",
          "switch": {
            "connect.fips.provider": {
              "BCJSSE": "io.confluent.kafka.security.fips.provider.BcFipsProviderCreator,io.confluent.kafka.security.fips.provider.BcFipsJsseProviderCreator,io.confluent.kafka.server.plugins.ssl.ConfluentTrustProviderCreator",
              "DEFAULT": null
            }
          }
        },
        {
          "name": "consumer.override.security.providers",
          "switch": {
            "connect.fips.provider": {
              "BCJSSE": "io.confluent.kafka.security.fips.provider.BcFipsProviderCreator,io.confluent.kafka.security.fips.provider.BcFipsJsseProviderCreator,io.confluent.kafka.server.plugins.ssl.ConfluentTrustProviderCreator",
              "DEFAULT": null
            }
          }
        },
        {
          "name": "admin.override.ssl.provider",
          "switch": {
            "connect.fips.provider": {
              "BCJSSE": "BCJSSE",
              "DEFAULT": null
            }
          }
        },
        {
          "name": "producer.override.ssl.provider",
          "switch": {
            "connect.fips.provider": {
              "BCJSSE": "BCJSSE",
              "DEFAULT": null
            }
          }
        },
        {
          "name": "consumer.override.ssl.provider",
          "switch": {
            "connect.fips.provider": {
              "BCJSSE": "BCJSSE",
              "DEFAULT": null
            }
          }
        },
        {
          "name": "admin.override.ssl.cipher.suites",
          "switch": {
            "connect.fips.provider": {
              "BCJSSE": "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_CCM,TLS_ECDHE_ECDSA_WITH_AES_128_CCM,TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8,TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256,TLS_AES_128_CCM_SHA256,TLS_AES_128_CCM_8_SHA256",
              "DEFAULT": null
            }
          }
        },
        {
          "name": "producer.override.ssl.cipher.suites",
          "switch": {
            "connect.fips.provider": {
              "BCJSSE": "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_CCM,TLS_ECDHE_ECDSA_WITH_AES_128_CCM,TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8,TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256,TLS_AES_128_CCM_SHA256,TLS_AES_128_CCM_8_SHA256",
              "DEFAULT": null
            }
          }
        },
        {
          "name": "consumer.override.ssl.cipher.suites",
          "switch": {
            "connect.fips.provider": {
              "BCJSSE": "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_CCM,TLS_ECDHE_ECDSA_WITH_AES_128_CCM,TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8,TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256,TLS_AES_128_CCM_SHA256,TLS_AES_128_CCM_8_SHA256",
              "DEFAULT": null
            }
          }
        },
        {
          "name": "admin.override.ssl.enabled.protocols",
          "switch": {
            "connect.fips.provider": {
              "BCJSSE": "TLSv1.2,TLSv1.3",
              "DEFAULT": null
            }
          }
        },
        {
          "name": "producer.override.ssl.enabled.protocols",
          "switch": {
            "connect.fips.provider": {
              "BCJSSE": "TLSv1.2,TLSv1.3",
              "DEFAULT": null
            }
          }
        },
        {
          "name": "consumer.override.ssl.enabled.protocols",
          "switch": {
            "connect.fips.provider": {
              "BCJSSE": "TLSv1.2,TLSv1.3",
              "DEFAULT": null
            }
          }
        },
        {
          "name": "producer.override.confluent.lkc.id",
          "switch": {
            "connect.metadata_property.kafka.itsl.embed.lkc": {
              "SKIP": "",
              "DEFAULT": "${connect.metadata_property.kafka.itsl.embed.lkc}"
            }
          }
        },
        {
          "name": "consumer.override.confluent.lkc.id",
          "switch": {
            "connect.metadata_property.kafka.itsl.embed.lkc": {
              "SKIP": "",
              "DEFAULT": "${connect.metadata_property.kafka.itsl.embed.lkc}"
            }
          }
        },
        {
          "name": "admin.override.confluent.lkc.id",
          "switch": {
            "connect.metadata_property.kafka.itsl.embed.lkc": {
              "SKIP": "",
              "DEFAULT": "${connect.metadata_property.kafka.itsl.embed.lkc}"
            }
          }
        },
        {
          "name": "producer.override.confluent.proxy.protocol.client.mode",
          "switch": {
            "connect.metadata_property.kafka.itsl.embed.lkc": {
              "SKIP": "PROXY",
              "DEFAULT": "LOCAL"
            }
          }
        },
        {
          "name": "producer.override.confluent.proxy.protocol.client.version",
          "switch": {
            "connect.metadata_property.kafka.itsl.embed.lkc": {
              "SKIP": "NONE",
              "DEFAULT": "V2"
            }
          }
        },
        {
          "name": "consumer.override.confluent.proxy.protocol.client.mode",
          "switch": {
            "connect.metadata_property.kafka.itsl.embed.lkc": {
              "SKIP": "PROXY",
              "DEFAULT": "LOCAL"
            }
          }
        },
        {
          "name": "consumer.override.confluent.proxy.protocol.client.version",
          "switch": {
            "connect.metadata_property.kafka.itsl.embed.lkc": {
              "SKIP": "NONE",
              "DEFAULT": "V2"
            }
          }
        },
        {
          "name": "admin.override.confluent.proxy.protocol.client.mode",
          "switch": {
            "connect.metadata_property.kafka.itsl.embed.lkc": {
              "SKIP": "PROXY",
              "DEFAULT": "LOCAL"
            }
          }
        },
        {
          "name": "admin.override.confluent.proxy.protocol.client.version",
          "switch": {
            "connect.metadata_property.kafka.itsl.embed.lkc": {
              "SKIP": "NONE",
              "DEFAULT": "V2"
            }
          }
        }
      ]
    },
    {
      "template_id": "topic-prefix-source",
      "abstract": true,
      "imports": [
        "common-source"
      ],
      "group_order": [
        "Kafka Cluster credentials",
        "How do you want to prefix table names?"
      ],
      "config_defs": [
        {
          "name": "topic.prefix",
          "type": "STRING",
          "required": true,
          "importance": "HIGH",
          "group": "How do you want to prefix table names?",
          "order_in_group": 1,
          "display_name": "Topic prefix",
          "documentation": "Prefix to prepend to table names to generate the name of the Apache Kafka\u00ae topic to publish data to.",
          "metadata": {
            "page": "SELECT_TOPICS",
            "order_in_page": 1
          }
        }
      ],
      "connector_configs": []
    },
    {
      "template_id": "common-source",
      "abstract": true,
      "config_defs": [
        {
          "name": "kafka.service.account.id",
          "type": "STRING",
          "required": false,
          "importance": "HIGH",
          "group": "Kafka Cluster credentials",
          "order_in_group": 2,
          "display_name": "Kafka Service Account",
          "documentation": "The Service Account that will be used to generate the API keys to communicate with Kafka Cluster.",
          "validators": [
            {
              "name": "common.conditional.required",
              "arguments": {
                "condition": "kafka.auth.mode==SERVICE_ACCOUNT"
              },
              "priority": "HIGHEST"
            },
            {
              "name": "kafka.credentials",
              "arguments": {
                "ssl.endpoint.identification.algorithm": "https",
                "sasl.mechanism": "PLAIN",
                "request.timeout.ms": "60000",
                "retry.backoff.ms": "500",
                "security.protocol": "SASL_SSL"
              }
            }
          ],
          "metadata": {
            "page": "KAFKA_CREDENTIALS",
            "order_in_page": 2,
            "visibility": "kafka.auth.mode==SERVICE_ACCOUNT"
          }
        },
        {
          "name": "kafka.api.secret",
          "type": "PASSWORD",
          "required": false,
          "importance": "HIGH",
          "group": "Kafka Cluster credentials",
          "order_in_group": 3,
          "display_name": "Kafka API Secret",
          "documentation": "Secret associated with Kafka API key. Required when kafka.auth.mode==KAFKA_API_KEY.",
          "validators": [
            {
              "name": "common.conditional.required",
              "arguments": {
                "condition": "kafka.auth.mode==KAFKA_API_KEY"
              },
              "priority": "HIGHEST"
            },
            {
              "name": "kafka.credentials.sanity"
            },
            {
              "name": "kafka.credentials",
              "arguments": {
                "ssl.endpoint.identification.algorithm": "https",
                "sasl.mechanism": "PLAIN",
                "request.timeout.ms": "60000",
                "retry.backoff.ms": "500",
                "security.protocol": "SASL_SSL"
              }
            }
          ],
          "dependents": [
            "kafka.api.key"
          ],
          "metadata": {
            "page": "KAFKA_CREDENTIALS",
            "order_in_page": 2,
            "visibility": "kafka.auth.mode==KAFKA_API_KEY"
          }
        },
        {
          "name": "datapreview.schemas.enable",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "default_value": "false",
          "display_name": "Show schemas in data preview request output",
          "group": "Kafka Cluster credentials",
          "order_in_group": 4,
          "documentation": "This config key only applies to data preview requests and governs whether the data preview output has record schema with it.\nThe visibility condition is set such that it can never be true.\nSo this key does not show in create connector UI.",
          "metadata": {
            "page": "KAFKA_CREDENTIALS",
            "order_in_page": 2,
            "visibility": "kafka.auth.mode==NEVER_VISIBLE"
          }
        },
        {
          "name": "errors.tolerance",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "group": "Additional Configs",
          "default_value": "none",
          "display_name": "errors.tolerance",
          "documentation": "Use this property if you would like to configure the connector's error handling behavior. WARNING: This property should be used with CAUTION for SOURCE CONNECTORS as it may lead to dataloss. If you set this property to 'all', the connector will not fail on errant records, but will instead log them (and send to DLQ for Sink Connectors) and continue processing. If you set this property to 'none', the connector task will fail on errant records.",
          "recommended_values": [
            "none",
            "all"
          ],
          "metadata": {
            "group_name": "Additional Configs",
            "page": "CONFIGURATION",
            "advanced": true,
            "additional.visible": "true"
          }
        },
        {
          "name": "producer.override.linger.ms",
          "type": "LONG",
          "required": "false",
          "importance": "LOW",
          "group": "Additional Configs",
          "display_name": "producer.override.linger.ms",
          "documentation": "The producer groups together any records that arrive in between request transmissions into a single batched request. More details can be found in the documentation: https://docs.confluent.io/platform/current/installation/configuration/producer-configs.html#linger-ms.",
          "metadata": {
            "group_name": "Additional Configs",
            "page": "CONFIGURATION",
            "advanced": true
          },
          "validators": [
            {
              "name": "common.range",
              "arguments": {
                "min": 100,
                "max": 1000
              }
            }
          ]
        }
      ],
      "connector_configs": [
        {
          "name": "topic.creation.default.replication.factor",
          "value": "3"
        },
        {
          "name": "topic.creation.default.partitions",
          "value": "1"
        },
        {
          "name": "errors.tolerance"
        },
        {
          "name": "producer.override.max.request.size",
          "switch": {
            "kafka.dedicated": {
              "true": "20971610",
              "false": "8388698"
            }
          }
        },
        {
          "name": "topic.creation.default.max.message.bytes",
          "switch": {
            "kafka.dedicated": {
              "true": "20971520",
              "false": "8388608"
            }
          }
        },
        {
          "name": "datapreview.schemas.enable"
        },
        {
          "name": "producer.override.sasl.jaas.config",
          "value": "org.apache.kafka.common.security.plain.PlainLoginModule required username=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.key}\" password=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.secret}\";"
        },
        {
          "name": "producer.override.security.protocol",
          "value": "SASL_SSL"
        },
        {
          "name": "producer.override.sasl.mechanism",
          "value": "PLAIN"
        },
        {
          "name": "admin.override.sasl.jaas.config",
          "value": "org.apache.kafka.common.security.plain.PlainLoginModule required username=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.key}\" password=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.secret}\";"
        },
        {
          "name": "admin.override.security.protocol",
          "value": "SASL_SSL"
        },
        {
          "name": "admin.override.sasl.mechanism",
          "value": "PLAIN"
        },
        {
          "name": "producer.override.linger.ms"
        }
      ]
    },
    {
      "template_id": "schema-registry",
      "abstract": true,
      "config_defs": [
        {
          "name": "schema.registry.url",
          "type": "STRING",
          "importance": "MEDIUM",
          "internal": true
        },
        {
          "name": "schema.context.name",
          "type": "STRING",
          "group": "Schema Config",
          "order_in_group": 1,
          "importance": "MEDIUM",
          "display_name": "Schema context",
          "documentation": "Add a schema context name. A schema context represents an independent scope in Schema Registry. It is a separate sub-schema tied to topics in different Kafka clusters that share the same Schema Registry instance. If not used, the connector uses the default schema configured for Schema Registry in your Confluent Cloud environment.",
          "default_value": "default",
          "validators": [
            {
              "name": "schema.context.name.exist.check",
              "priority": "LOWER"
            }
          ],
          "dependents": [
            "schema.registry.url"
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "order_in_page": 1
          }
        }
      ],
      "connector_configs": []
    },
    {
      "template_id": "common-mongodb",
      "abstract": true,
      "config_defs": [
        {
          "name": "mongodb.connection.uri.unsupported.options",
          "type": "STRING",
          "importance": "LOW",
          "internal": true
        }
      ],
      "connector_configs": []
    },
    {
      "template_id": "source-connector-output-data-format",
      "abstract": true,
      "config_defs": [
        {
          "name": "output.data.format",
          "type": "STRING",
          "required": true,
          "default_value": "JSON",
          "importance": "HIGH",
          "group": "Output messages",
          "order_in_group": 1,
          "display_name": "Select output record value format",
          "alias": "data.format",
          "documentation": "Sets the output Kafka record value format. Valid entries are AVRO, JSON_SR, PROTOBUF, or JSON. Note that you need to have Confluent Cloud Schema Registry configured if using a schema-based message format like AVRO, JSON_SR, and PROTOBUF",
          "recommended_values": [
            "AVRO",
            "JSON_SR",
            "PROTOBUF",
            "JSON"
          ],
          "validators": [
            {
              "name": "sr.integration"
            }
          ],
          "dependents": [
            "schema.registry.url"
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": false,
            "order_in_page": 2,
            "group_name": "Output messages"
          }
        },
        {
          "name": "value.converter.schemas.enable",
          "type": "BOOLEAN",
          "required": false,
          "default_value": "false",
          "importance": "LOW",
          "group": "Additional Configs",
          "alias": "schemas.enable",
          "display_name": "value.converter.schemas.enable",
          "documentation": "Include schemas within each of the serialized values. Input messages must contain `schema` and `payload` fields and may not contain additional fields. For plain JSON data, set this to `false`. Applicable for JSON Converter.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "additional.visible": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.replace.null.with.default",
          "type": "BOOLEAN",
          "required": false,
          "default_value": "true",
          "alias": "replace.null.with.default",
          "importance": "LOW",
          "group": "Additional Configs",
          "display_name": "value.converter.replace.null.with.default",
          "documentation": "Whether to replace fields that have a default value and that are null to the default value. When set to true, the default value is used, otherwise null is used. Applicable for JSON Converter.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "group_name": "Additional Configs",
            "additional.visible": "true"
          }
        },
        {
          "name": "value.converter.ignore.default.for.nullables",
          "alias": "ignore.default.for.nullables",
          "type": "BOOLEAN",
          "required": false,
          "default_value": "false",
          "importance": "LOW",
          "group": "Additional Configs",
          "display_name": "value.converter.ignore.default.for.nullables",
          "documentation": "When set to true, this property ensures that the corresponding record in Kafka is NULL, instead of showing the default column value. Applicable for AVRO,PROTOBUF and JSON_SR Converters.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "group_name": "Additional Configs",
            "additional.visible": "true"
          }
        },
        {
          "name": "value.converter.scrub.invalid.names",
          "type": "BOOLEAN",
          "documentation": "Whether to scrub invalid names by replacing invalid characters with valid characters. Applicable for Avro and Protobuf Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.scrub.invalid.names",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        }
      ],
      "connector_configs": [
        {
          "name": "value.converter",
          "switch": {
            "output.data.format": {
              "AVRO": "io.confluent.connect.avro.AvroConverter",
              "JSON_SR": "io.confluent.connect.json.JsonSchemaConverter",
              "PROTOBUF": "io.confluent.connect.protobuf.ProtobufConverter",
              "JSON": "org.apache.kafka.connect.json.JsonConverter"
            }
          }
        },
        {
          "name": "value.converter.schemas.enable"
        },
        {
          "name": "value.converter.replace.null.with.default"
        },
        {
          "name": "value.converter.schema.registry.url",
          "switch": {
            "output.data.format": {
              "AVRO": "${schema.registry.url}",
              "JSON_SR": "${schema.registry.url}",
              "PROTOBUF": "${schema.registry.url}"
            }
          }
        },
        {
          "name": "value.converter.basic.auth.credentials.source",
          "switch": {
            "output.data.format": {
              "AVRO": "USER_INFO",
              "JSON_SR": "USER_INFO",
              "PROTOBUF": "USER_INFO"
            }
          }
        },
        {
          "name": "value.converter.basic.auth.user.info",
          "switch": {
            "output.data.format": {
              "AVRO": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}",
              "JSON_SR": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}",
              "PROTOBUF": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}"
            }
          }
        },
        {
          "name": "value.converter.ignore.default.for.nullables"
        },
        {
          "name": "value.converter.scrub.invalid.names",
          "dynamic.mapper": {
            "name": "value.converter.scrub.invalid.names.mapper"
          }
        }
      ]
    },
    {
      "template_id": "output-key-format",
      "abstract": true,
      "config_defs": [
        {
          "name": "output.key.format",
          "type": "STRING",
          "required": false,
          "default_value": "STRING",
          "importance": "HIGH",
          "group": "Output messages",
          "order_in_group": 2,
          "display_name": "Output Kafka record key format",
          "alias": "key.format",
          "documentation": "Sets the output Kafka record key format. Valid entries are AVRO, JSON_SR, PROTOBUF, STRING or JSON. Note that you need to have Confluent Cloud Schema Registry configured if using a schema-based message format like AVRO, JSON_SR, and PROTOBUF",
          "recommended_values": [
            "AVRO",
            "JSON_SR",
            "PROTOBUF",
            "JSON",
            "STRING"
          ],
          "validators": [
            {
              "name": "sr.integration"
            },
            {
              "name": "common.is.recommended.value"
            }
          ],
          "dependents": [
            "schema.registry.url"
          ],
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": false,
            "order_in_page": 2
          }
        },
        {
          "name": "key.converter.schemas.enable",
          "type": "BOOLEAN",
          "required": false,
          "default_value": "false",
          "importance": "LOW",
          "group": "Additional Configs",
          "display_name": "key.converter.schemas.enable",
          "documentation": "Include schemas within each of the serialized keys. Input message keys must contain `schema` and `payload` fields and may not contain additional fields. For plain JSON data, set this to `false`. Applicable for JSON Key Converter.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "key.converter.replace.null.with.default",
          "type": "BOOLEAN",
          "required": false,
          "default_value": "true",
          "importance": "LOW",
          "group": "Additional Configs",
          "display_name": "key.converter.replace.null.with.default",
          "documentation": "Whether to replace fields that have a default value and that are null to the default value. When set to true, the default value is used, otherwise null is used. Applicable for JSON Key Converter.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "group_name": "Additional Configs"
          }
        }
      ],
      "connector_configs": [
        {
          "name": "key.converter",
          "switch": {
            "output.key.format": {
              "AVRO": "io.confluent.connect.avro.AvroConverter",
              "JSON_SR": "io.confluent.connect.json.JsonSchemaConverter",
              "PROTOBUF": "io.confluent.connect.protobuf.ProtobufConverter",
              "STRING": "org.apache.kafka.connect.storage.StringConverter",
              "JSON": "org.apache.kafka.connect.json.JsonConverter"
            }
          }
        },
        {
          "name": "key.converter.schema.registry.url",
          "switch": {
            "output.key.format": {
              "AVRO": "${schema.registry.url}",
              "JSON_SR": "${schema.registry.url}",
              "PROTOBUF": "${schema.registry.url}"
            }
          }
        },
        {
          "name": "key.converter.basic.auth.credentials.source",
          "switch": {
            "output.key.format": {
              "AVRO": "USER_INFO",
              "JSON_SR": "USER_INFO",
              "PROTOBUF": "USER_INFO"
            }
          }
        },
        {
          "name": "key.converter.basic.auth.user.info",
          "switch": {
            "output.key.format": {
              "AVRO": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}",
              "JSON_SR": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}",
              "PROTOBUF": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}"
            }
          }
        },
        {
          "name": "key.converter.schemas.enable"
        },
        {
          "name": "key.converter.replace.null.with.default"
        }
      ]
    },
    {
      "template_id": "super",
      "abstract": true,
      "config_defs": [
        {
          "name": "auto.restart.on.user.error",
          "type": "BOOLEAN",
          "required": false,
          "default_value": "true",
          "importance": "MEDIUM",
          "group": "Auto-restart policy",
          "order_in_group": 1,
          "display_name": "Enable Connector Auto-restart",
          "documentation": "Enable connector to automatically restart on user-actionable errors.",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": true,
            "group_name": "Auto-restart policy"
          }
        },
        {
          "name": "value.converter.enhanced.avro.schema.support",
          "type": "BOOLEAN",
          "documentation": "Enable enhanced schema support to preserve package information and Enums. Applicable for Avro Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.enhanced.avro.schema.support",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.connect.meta.data",
          "type": "BOOLEAN",
          "documentation": "Allow the Connect converter to add its metadata to the output schema. Applicable for Avro Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.connect.meta.data",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs",
            "additional.visible": "true"
          }
        },
        {
          "name": "value.converter.enhanced.protobuf.schema.support",
          "type": "BOOLEAN",
          "documentation": "Enable enhanced schema support to preserve package information. Applicable for Protobuf Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.enhanced.protobuf.schema.support",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.generate.index.for.unions",
          "type": "BOOLEAN",
          "documentation": "Whether to generate an index suffix for unions. Applicable for Protobuf Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.generate.index.for.unions",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.int.for.enums",
          "type": "BOOLEAN",
          "documentation": "Whether to represent enums as integers. Applicable for Protobuf Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.int.for.enums",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.optional.for.nullables",
          "type": "BOOLEAN",
          "documentation": "Whether nullable fields should be specified with an optional label. Applicable for Protobuf Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.optional.for.nullables",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.generate.struct.for.nulls",
          "type": "BOOLEAN",
          "documentation": "Whether to generate a struct variable for null values. Applicable for Protobuf Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.generate.struct.for.nulls",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.wrapper.for.nullables",
          "type": "BOOLEAN",
          "documentation": "Whether nullable fields should use primitive wrapper messages. Applicable for Protobuf Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.wrapper.for.nullables",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.wrapper.for.raw.primitives",
          "type": "BOOLEAN",
          "documentation": "Whether a wrapper message should be interpreted as a raw primitive at root level. Applicable for Protobuf Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.wrapper.for.raw.primitives",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.object.additional.properties",
          "type": "BOOLEAN",
          "documentation": "Whether to allow additional properties for object schemas. Applicable for JSON_SR Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.object.additional.properties",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.use.optional.for.nonrequired",
          "type": "BOOLEAN",
          "documentation": "Whether to set non-required properties to be optional. Applicable for JSON_SR Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.use.optional.for.nonrequired",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.decimal.format",
          "type": "STRING",
          "recommended_values": [
            "BASE64",
            "NUMERIC"
          ],
          "documentation": "Specify the JSON/JSON_SR serialization format for Connect DECIMAL logical type values with two allowed literals:\nBASE64 to serialize DECIMAL logical types as base64 encoded binary data and\nNUMERIC to serialize Connect DECIMAL logical type values in JSON/JSON_SR as a number representing the decimal value.",
          "group": "Additional Configs",
          "alias": "json.output.decimal.format",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.decimal.format",
          "default_value": "BASE64",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs",
            "additional.visible": "true"
          }
        },
        {
          "name": "value.converter.auto.register.schemas",
          "type": "BOOLEAN",
          "documentation": "Specify if the Serializer should attempt to register the Schema.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.auto.register.schemas",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.use.latest.version",
          "type": "BOOLEAN",
          "documentation": "Use latest version of schema in subject for serialization when auto.register.schemas is false.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.use.latest.version",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.latest.compatibility.strict",
          "type": "BOOLEAN",
          "documentation": "Verify latest subject version is backward compatible when `use.latest.version` is `true`.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.latest.compatibility.strict",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "key.converter.key.subject.name.strategy",
          "type": "STRING",
          "default_value": "TopicNameStrategy",
          "recommended_values": [
            "TopicNameStrategy",
            "RecordNameStrategy",
            "TopicRecordNameStrategy"
          ],
          "alias": "key.subject.name.strategy",
          "documentation": "How to construct the subject name for key schema registration.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "key.converter.key.subject.name.strategy",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs",
            "additional.visible": "true"
          }
        },
        {
          "name": "value.converter.value.subject.name.strategy",
          "type": "STRING",
          "recommended_values": [
            "TopicNameStrategy",
            "RecordNameStrategy",
            "TopicRecordNameStrategy"
          ],
          "default_value": "TopicNameStrategy",
          "alias": "subject.name.strategy,value.subject.name.strategy",
          "documentation": "Determines how to construct the subject name under which the value schema is registered with Schema Registry.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.value.subject.name.strategy",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs",
            "additional.visible": "true"
          }
        },
        {
          "name": "value.converter.reference.subject.name.strategy",
          "type": "STRING",
          "recommended_values": [
            "DefaultReferenceSubjectNameStrategy",
            "QualifiedReferenceSubjectNameStrategy"
          ],
          "default_value": "DefaultReferenceSubjectNameStrategy",
          "documentation": "Set the subject reference name strategy for value. Valid entries are DefaultReferenceSubjectNameStrategy or QualifiedReferenceSubjectNameStrategy. Note that the subject reference name strategy can be selected only for PROTOBUF format with the default strategy being DefaultReferenceSubjectNameStrategy.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.reference.subject.name.strategy",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs",
            "additional.visible": "true"
          }
        },
        {
          "name": "value.converter.allow.optional.map.keys",
          "type": "BOOLEAN",
          "documentation": "Allow optional string map key when converting from Connect Schema to Avro Schema. Applicable for Avro Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.allow.optional.map.keys",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.flatten.singleton.unions",
          "type": "BOOLEAN",
          "default_value": "false",
          "documentation": "Whether to flatten singleton unions. Applicable for Avro and JSON_SR Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.flatten.singleton.unions",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.optional.for.proto2",
          "type": "BOOLEAN",
          "documentation": "Whether proto2 optionals are supported. Applicable for Protobuf Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.optional.for.proto2",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "value.converter.flatten.unions",
          "type": "BOOLEAN",
          "documentation": "Whether to flatten unions (oneofs). Applicable for Protobuf Converters.",
          "group": "Additional Configs",
          "required": false,
          "importance": "LOW",
          "display_name": "value.converter.flatten.unions",
          "metadata": {
            "page": "CONFIGURATION",
            "advanced": "true",
            "group_name": "Additional Configs"
          }
        },
        {
          "name": "header.converter",
          "type": "STRING",
          "required": false,
          "importance": "LOW",
          "group": "Additional Configs",
          "display_name": "header.converter",
          "documentation": "The converter class for the headers. This is used to serialize and deserialize the headers of the messages.",
          "recommended_values": [
            "org.apache.kafka.connect.storage.SimpleHeaderConverter",
            "org.apache.kafka.connect.storage.StringConverter",
            "org.apache.kafka.connect.json.JsonConverter",
            "org.apache.kafka.connect.converters.BooleanConverter",
            "org.apache.kafka.connect.converters.DoubleConverter",
            "org.apache.kafka.connect.converters.FloatConverter",
            "org.apache.kafka.connect.converters.IntegerConverter",
            "org.apache.kafka.connect.converters.LongConverter",
            "org.apache.kafka.connect.converters.ShortConverter"
          ],
          "metadata": {
            "group_name": "Additional Configs",
            "page": "CONFIGURATION",
            "advanced": true
          }
        }
      ],
      "connector_configs": [
        {
          "name": "auto.restart.on.user.error"
        },
        {
          "name": "value.converter.enhanced.avro.schema.support"
        },
        {
          "name": "value.converter.connect.meta.data"
        },
        {
          "name": "value.converter.enhanced.protobuf.schema.support"
        },
        {
          "name": "value.converter.generate.index.for.unions"
        },
        {
          "name": "value.converter.int.for.enums"
        },
        {
          "name": "value.converter.optional.for.nullables"
        },
        {
          "name": "value.converter.generate.struct.for.nulls"
        },
        {
          "name": "value.converter.wrapper.for.nullables"
        },
        {
          "name": "value.converter.wrapper.for.raw.primitives"
        },
        {
          "name": "value.converter.object.additional.properties"
        },
        {
          "name": "value.converter.use.optional.for.nonrequired"
        },
        {
          "name": "value.converter.decimal.format"
        },
        {
          "name": "value.converter.auto.register.schemas",
          "dynamic.mapper": {
            "name": "value.converter.auto.register.schemas.mapper"
          }
        },
        {
          "name": "value.converter.use.latest.version",
          "dynamic.mapper": {
            "name": "value.converter.use.latest.version.mapper"
          }
        },
        {
          "name": "value.converter.latest.compatibility.strict"
        },
        {
          "name": "value.converter.value.subject.name.strategy",
          "dynamic.mapper": {
            "name": "value.converter.value.subject.name.strategy.mapper"
          }
        },
        {
          "name": "key.converter.key.subject.name.strategy",
          "dynamic.mapper": {
            "name": "value.converter.value.subject.name.strategy.mapper"
          }
        },
        {
          "name": "value.converter.reference.subject.name.strategy",
          "dynamic.mapper": {
            "name": "value.converter.reference.subject.name.strategy.mapper"
          }
        },
        {
          "name": "value.converter.allow.optional.map.keys"
        },
        {
          "name": "value.converter.flatten.singleton.unions"
        },
        {
          "name": "value.converter.optional.for.proto2"
        },
        {
          "name": "value.converter.flatten.unions"
        },
        {
          "name": "header.converter"
        }
      ]
    }
  ],
  "all_config_def_names": [
    "batch.size",
    "change.stream.full.document",
    "change.stream.full.document.before.change",
    "collection",
    "connection.host",
    "connection.password",
    "connection.user",
    "connector.class",
    "database",
    "datapreview.schemas.enable",
    "heartbeat.interval.ms",
    "heartbeat.topic.name",
    "kafka.api.key",
    "kafka.api.secret",
    "kafka.auth.mode",
    "kafka.service.account.id",
    "linger.ms",
    "mongo.errors.deadletterqueue.topic.name",
    "mongo.errors.tolerance",
    "name",
    "offset.partition.name",
    "output.data.format",
    "output.json.format",
    "output.key.format",
    "output.schema.infer.value",
    "output.schema.key",
    "output.schema.value",
    "pipeline",
    "poll.await.time.ms",
    "poll.max.batch.size",
    "producer.batch.size",
    "publish.full.document.only",
    "publish.full.document.only.tombstone.on.delete",
    "schema.context.name",
    "server.api.deprecation.errors",
    "server.api.strict",
    "server.api.version",
    "startup.mode",
    "startup.mode.copy.existing.namespace.regex",
    "startup.mode.copy.existing.pipeline",
    "startup.mode.timestamp.start.at.operation.time",
    "tasks.max",
    "topic.namespace.map",
    "topic.prefix",
    "topic.separator",
    "topic.suffix"
  ],
  "all_connector_configs": [
    {
      "name": "consumer.override.sasl.jaas.config",
      "value": "org.apache.kafka.common.security.plain.PlainLoginModule required username=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.key}\" password=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.secret}\";"
    },
    {
      "name": "producer.override.sasl.jaas.config",
      "value": "org.apache.kafka.common.security.plain.PlainLoginModule required username=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.key}\" password=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.secret}\";"
    },
    {
      "name": "admin.override.sasl.jaas.config",
      "value": "org.apache.kafka.common.security.plain.PlainLoginModule required username=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.key}\" password=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.secret}\";"
    },
    {
      "name": "value.converter.schema.registry.url",
      "switch": {
        "output.data.format": {
          "AVRO": "${schema.registry.url}",
          "JSON_SR": "${schema.registry.url}",
          "PROTOBUF": "${schema.registry.url}"
        }
      }
    },
    {
      "name": "value.converter.basic.auth.user.info",
      "switch": {
        "output.data.format": {
          "AVRO": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}",
          "JSON_SR": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}",
          "PROTOBUF": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}"
        }
      }
    },
    {
      "name": "connection.uri",
      "switch": {
        "connection.host": {
          "": null,
          "DEFAULT": "mongodb+srv://${connection.user}:${connection.password}@${connection.host}"
        }
      }
    },
    {
      "name": "producer.override.linger.ms",
      "value": "${linger.ms}"
    },
    {
      "name": "producer.override.batch.size",
      "value": "${producer.batch.size}"
    },
    {
      "name": "consumer.override.bootstrap.servers",
      "switch": {
        "connect.metadata_property.kafka.itsl.bootstrap.servers": {
          "UNSET": "${kafka.endpoint}",
          "DEFAULT": "${connect.metadata_property.kafka.itsl.bootstrap.servers}"
        }
      }
    },
    {
      "name": "producer.override.bootstrap.servers",
      "switch": {
        "connect.metadata_property.kafka.itsl.bootstrap.servers": {
          "UNSET": "${kafka.endpoint}",
          "DEFAULT": "${connect.metadata_property.kafka.itsl.bootstrap.servers}"
        }
      }
    },
    {
      "name": "admin.override.bootstrap.servers",
      "switch": {
        "connect.metadata_property.kafka.itsl.bootstrap.servers": {
          "UNSET": "${kafka.endpoint}",
          "DEFAULT": "${connect.metadata_property.kafka.itsl.bootstrap.servers}"
        }
      }
    },
    {
      "name": "producer.override.confluent.lkc.id",
      "switch": {
        "connect.metadata_property.kafka.itsl.embed.lkc": {
          "SKIP": "",
          "DEFAULT": "${connect.metadata_property.kafka.itsl.embed.lkc}"
        }
      }
    },
    {
      "name": "consumer.override.confluent.lkc.id",
      "switch": {
        "connect.metadata_property.kafka.itsl.embed.lkc": {
          "SKIP": "",
          "DEFAULT": "${connect.metadata_property.kafka.itsl.embed.lkc}"
        }
      }
    },
    {
      "name": "admin.override.confluent.lkc.id",
      "switch": {
        "connect.metadata_property.kafka.itsl.embed.lkc": {
          "SKIP": "",
          "DEFAULT": "${connect.metadata_property.kafka.itsl.embed.lkc}"
        }
      }
    },
    {
      "name": "producer.override.sasl.jaas.config",
      "value": "org.apache.kafka.common.security.plain.PlainLoginModule required username=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.key}\" password=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.secret}\";"
    },
    {
      "name": "admin.override.sasl.jaas.config",
      "value": "org.apache.kafka.common.security.plain.PlainLoginModule required username=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.key}\" password=\"${file:/mnt/secrets/connect-external-secrets-{{.logicalClusterId}}.properties:kafka.api.secret}\";"
    },
    {
      "name": "value.converter.schema.registry.url",
      "switch": {
        "output.data.format": {
          "AVRO": "${schema.registry.url}",
          "JSON_SR": "${schema.registry.url}",
          "PROTOBUF": "${schema.registry.url}"
        }
      }
    },
    {
      "name": "value.converter.basic.auth.user.info",
      "switch": {
        "output.data.format": {
          "AVRO": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}",
          "JSON_SR": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}",
          "PROTOBUF": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}"
        }
      }
    },
    {
      "name": "key.converter.schema.registry.url",
      "switch": {
        "output.key.format": {
          "AVRO": "${schema.registry.url}",
          "JSON_SR": "${schema.registry.url}",
          "PROTOBUF": "${schema.registry.url}"
        }
      }
    },
    {
      "name": "key.converter.basic.auth.user.info",
      "switch": {
        "output.key.format": {
          "AVRO": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}",
          "JSON_SR": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}",
          "PROTOBUF": "${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:username}:${file:/mnt/secrets/connect-sr-{{.logicalClusterId}}.properties:password}"
        }
      }
    }
  ],
  "config_defs_not_used_as_connector_names": [
    "connection.host",
    "connection.password",
    "connection.user",
    "connector.class",
    "kafka.api.key",
    "kafka.api.secret",
    "kafka.auth.mode",
    "kafka.service.account.id",
    "linger.ms",
    "name",
    "output.data.format",
    "output.json.format",
    "output.key.format",
    "producer.batch.size",
    "schema.context.name"
  ]
}